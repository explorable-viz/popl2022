\documentclass[usenames,dvipsnames,preprint]{sigplanconf}

\usepackage{float}
\usepackage{mathpartir}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{soul}
\usepackage[usenames,dvipsnames]{color}
\usepackage{MnSymbol}
\usepackage{xspace}
\usepackage{mathtools}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{breakurl}
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage[scaled=0.8]{beramono}
\usepackage{upgreek}
\usepackage{pifont}
\usepackage{framed}
\usepackage{subdepth}
\usepackage{tikz}
\usepackage{dashundergaps}


\usetikzlibrary{shapes,chains,positioning}

\input{macros-common}
\input{macros}

\setulcolor{blue}

\makeatletter
  \let\@copyrightspace\relax
\makeatother

\begin{document}

\title{Demand-indexed computation}

\authorinfo{}{}{}{}

\maketitle

\input{fig-syntax}
\input{fig-typing}
\input{fig-typing-patterns}
\input{fig-typing-values}
\input{fig-eval}
\input{fig-demand}
\input{fig-match}

\section{Typing}

\begin{enumerate}
\item We omit the rules for $\kw{snd}$ and $\kw{inr}$ throughout.
\item The set $D_{\tau}$ of ``demands'' of type $\tau$ form a Boolean
  algebra $(D_{\tau},\bot,\top,\meet,\join,\neg)$.
\item Moding: for all judgements, contexts and expressions are
  inputs. For types, input polarity is indicated by $\tycheck$ and
  output by $\synth$.
\item As an example of a disjunctive demand, $\ttt{Nil} \join
  \ttt{Cons}(\bot,\ttt{Nil})$ would desugar to
  $\exRoll{(\exInlr{\exUnit}{\exPair{\bot}{\exRoll{\exInl{\exUnit}}}})}$. Forcing
  a list computation with this demand would cause it to get stuck if
  it tried to produce a two-element list.
\end{enumerate}

\section{Evaluation}

\begin{lemma}[Determinism]
\label{lem:eval:deterministic}
\item
\begin{enumerate}
\item If $e \eval_{u} v$ and $e \eval_{u} v'$ then $v = v'$.
\item If $r \seval_{u} v \synth \tau$ and $r \seval_{u} v' \synth
  \tau'$ then $v = v'$ and $\tau = \tau'$.
\end{enumerate}
\end{lemma}
\begin{proof}
  Simultaneous induction, relying on the $u \sqgt \bot$
  side-conditions in \figref{eval}.
\end{proof}

In the first judgement, when $e$ is of the form $r$ and the demand is
$\bot$, there are two possibilities that both lead to the same
result. (We can suspend $e$ directly, or go via the other judgement.)
In the second judgement, when $r$ is of the form $\exAnnot{e}{\tau}$
and the demand is $\bot$, we need the $u \sqgt \bot$ side-condition to
ensure that we obtain we want a suspension of an annotated term, not
an annotated suspension.

The evaluation judgement $e \seval_{u} v \synth \tau$ for synthesis
terms returns the type $\tau$ of $v$. When matching unpacks an
expression $e$ from a suspension $\exSuspend{e}$ in order to
substitute it, $e$ can be coerced into a synthesis form by annotating
it with $\tau$. If it is already in synthesis form $r$ then we
substitute $r$ directly.

Substitution of a closed synthesis term for a variable is
type-preserving.

\begin{lemma}[Substitution]
\label{lem:substitution:sound}
Suppose $\cxtEmpty \vdash r \synth \tau$.
\begin{enumerate}
\item If $\cxtExtend{\Gamma}{x}{\tau} \vdash e \tycheck \tau'$ then
  $\Gamma \vdash \subst{r}{x}{e} \tycheck \tau'$.
\item If $\cxtExtend{\Gamma}{x}{\tau} \vdash r \synth \tau'$ then
  $\Gamma \vdash \subst{r}{x}{r} \synth \tau'$.
\end{enumerate}
\end{lemma}

Matching, if it succeeds with a unique expression, is also
type-preserving.

\begin{lemma}[Matching]
\label{lem:matching:sound}
  Suppose $\vdash v \tycheck \sigma$. If $\Gamma;\vec{p} \tycheck
  \sigma \vdash \vec{e} \tycheck \tau$ and
  $\match{v}{\vec{\exBranch{p}{e}}} = e'$, then $\Gamma \vdash e'
  \tycheck \tau$.
\end{lemma}

\begin{lemma}[Soundness of typing]
\item
\begin{enumerate}
\item If $\cxtEmpty \vdash e \tycheck \tau$ and $e \eval_{u} v$ then
  $\vdash v \tycheck \tau$.
\item If $\cxtEmpty \vdash r \synth \tau$ and $r \seval_{u} v \synth
  \tau'$ then $\tau' = \tau$ and $\vdash v \tycheck \tau$.
\end{enumerate}
\end{lemma}
\begin{proof}
  Simultaneous induction. In the suspension rule for synthesis
  evaluation, we need that typing is deterministic. For the case rule
  and app rules we need that substitution and matching preserve types
  (\lemrefTwo{substitution:sound}{matching:sound}).
\end{proof}

If a program terminates for demand $u$, then the evaluation relation
is total if we restrict it to that program and to the prefixes of
$u$. It is also monotone.

\begin{theorem}[Total and monotonic]
  If $e \eval_{u} v$ and $u' \sqleq u$ then $e \eval_{u'} v'$ with $v'
  \sqleq v$.
\end{theorem}

\section{Applications}

\begin{enumerate}
\item Interactively change the demand on the output of a program to
  see more of the output. Can already be achieved by running a
  suspended part of a lazy result as a new top-level computation, but
  with our approach there is an explicit notion of precisely how much
  demand is being placed on the entire computation.
\item We can use this demand specification to force a computation to a
  certain depth without having to repeat the interactions. E.g., for
  restoring the state of a computation.
\item If the type of a terminating program specifies that it can yield
  a result of a certain size, then it will also terminate for any
  smaller demand, with a smaller output.
\end{enumerate}

\pagebreak
\input{fig-join}

{
\bibliographystyle{plain}
\small
\bibliography{bib}
}

\end{document}
