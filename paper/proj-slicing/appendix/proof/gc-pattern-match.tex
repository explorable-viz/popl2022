\subsection{\thmref{gc-pattern-match}}
\proofContext{gc-pattern-match}
\begin{proof}
\small
\stepcounter{myequation}
\begin{flalign}
&
u^\dagger, \sigma^\dagger \lookupR \rho^\dagger, \kappa^\dagger
\text{ with }
u^\dagger = \annot{v^\dagger}{\smash{\alpha^\dagger}}
&
\text{suppose ($u^\dagger, \sigma^\dagger, \rho^\dagger, \kappa^\dagger, v^\dagger$)}
\notag
\\
\intertext{\textbf{Part (i)}}
&
u, \sigma \leq u^\dagger, \sigma^\dagger
&
\text{suppose ($u, \sigma$)}
\notag
\\
\intertext{Subgoal:}
&
u, \sigma \mathrel{\lookupR\unlookupR{v^\dagger, \sigma^\dagger}\leq} u, \sigma
&
\text{}
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-var}}]
   {
      \strut
   }
   {
      \annot{v}{\alpha}, \trieVar{x}{\annot{\iota}{\alpha'}}
      \lookupR
      \envExtend{\envEmpty}{x}{\annot{v}{\alpha}}, \annot{\iota}{\alpha'}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-var}}]
   {
      \strut
   }
   {
     \envExtend{\envEmpty}{x}{\annot{v}{\alpha}}, \annot{\iota}{\alpha'}
     \unlookupR{v^\dagger, \trieVar{x}{\kappa^\dagger}}
     \annot{v}{\alpha}, \trieVar{x}{\annot{\iota}{\alpha'}}
   }
\end{smathpar}
}
&
\text{\defref{unmatch}}
\notag
\\
&
\qedLocal
\annot{v}{\alpha}, \trieVar{x}{\annot{\iota}{\alpha'}}
\leq
\annot{v}{\alpha}, \trieVar{x}{\annot{\iota}{\alpha'}}
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-unit}}]
   {
      \strut
   }
   {
      \annot{\exUnit}{\alpha}, \trieUnit{\annot{\iota}{\alpha'}}
      \lookupR
      \envEmpty, \annot{\iota}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-unit}}]
   {
      \strut
   }
   {
     \envEmpty, \annot{\iota}{\alpha \wedge \alpha'}
     \unlookupR{\exUnit, \trieUnit{\kappa^\dagger}}
     \annot{\exUnit}{\alpha \wedge \alpha'}, \trieUnit{\annot{\iota}{\alpha \wedge \alpha'}}
   }
\end{smathpar}
}
&
\text{\defref{unmatch}}
\notag
\\
&
\qedLocal
\annot{\exUnit}{\alpha \wedge \alpha'}, \trieUnit{\annot{\iota}{\alpha \wedge \alpha'}}
\leq
\annot{\exUnit}{\alpha'}, \trieUnit{\annot{\iota}{\alpha}}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-inl}}]
   {
      u, \sigma \lookupR \rho, \annot{\iota}{\alpha'}
   }
   {
      \annot{(\exInl{u})}{\alpha}, \trieSum{\sigma}{\tau} \lookupR \rho, \annot{\iota}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-inl}}]
   {
     \rho, \annot{\iota}{\alpha \wedge \alpha'} \unlookupR{v^\dagger, \sigma^\dagger} u', \sigma'
   }
   {
     \rho, \annot{\iota}{\alpha \wedge \alpha'}
     \unlookupR{\exInl{v^\dagger}, \trieSum{\sigma^\dagger}{\tau^\dagger}}
     \annot{(\exInl{u'})}{\alpha \wedge \alpha'}, \trieSum{\sigma'}{\annot{\tau}{\bot}}
   }
\end{smathpar}
}
&
\text{
   IH; $\annot{\iota}{\alpha \wedge \alpha'} \leq \annot{\iota}{\alpha'}$
}
\notag
\\
&
\indent
u', \sigma' \leq u, \sigma
&
\text{$\unlookupR{}$ monotone}
\notag
\\
&
\qedLocal
\annot{(\exInl{u'})}{\alpha \wedge \alpha'}, \trieSum{\sigma'}{\annot{\tau}{\bot}}
\leq
\annot{(\exInl{u})}{\alpha}, \trieSum{\sigma}{\tau}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-inr}}]
   {
      u, \tau \lookupR \rho, \annot{\iota}{\alpha'}
   }
   {
      \annot{(\exInr{u})}{\alpha}, \trieSum{\sigma}{\tau} \lookupR \rho, \annot{\iota}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-inr}}]
   {
     \rho, \annot{\iota}{\alpha \wedge \alpha'} \unlookupR{v^\dagger, \tau^\dagger} u', \tau'
   }
   {
     \rho, \annot{\iota}{\alpha \wedge \alpha'}
     \unlookupR{\exInr{v^\dagger}, \trieSum{\sigma^\dagger}{\tau^\dagger}}
     \annot{(\exInr{u'})}{\alpha \wedge \alpha'}, \trieSum{\annot{\sigma}{\bot}}{\tau'}
   }
\end{smathpar}
}
&
\text{
   IH; $\annot{\iota}{\alpha \wedge \alpha'} \leq \annot{\iota}{\alpha'}$
}
\notag
\\
&
\indent
u', \sigma' \leq u, \sigma
&
\text{$\unlookupR{}$ monotone}
\notag
\\
&
\qedLocal
\annot{(\exInr{u'})}{\alpha \wedge \alpha'}, \trieSum{\annot{\sigma}{\bot}}{\tau'}
\leq
\annot{(\exInr{u})}{\alpha}, \trieSum{\sigma}{\tau}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-pair}}]
   {
      u_1, \sigma \lookupR \rho_1, \annot{\tau}{\alpha'}
      \\
      u_2, \tau \lookupR \rho_2, \annot{\iota}{\alpha^\twoPrime}
   }
   {
      \annot{\exPair{u_1}{u_2}}{\alpha}, \trieProd{\sigma}
      \lookupR
      \rho_1 \concat \rho_2, \annot{\iota}{\alpha \wedge \alpha' \alpha^\twoPrime}
   }
\end{smathpar}
}
&
\notag
\\[2mm]
&
\indent
\rho_2, \annot{\iota}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime} \unlookupR{v_2^\dagger, \tau^\dagger} u_2', \tau'
\text{ with }
u_2', \tau' \leq u_2, \tau
&
\indent
\text{IH; $\annot{\iota}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime} \leq \annot{\iota}{\alpha^\twoPrime}$}
\notag
\\
&
\indent
\rho_1, \annot{\tau'}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime} \unlookupR{v_1^\dagger, \sigma^\dagger} u_1', \sigma'
\text{ with }
u_1', \sigma' \leq u_1, \sigma
&
\text{IH; $\annot{\tau'}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime} \leq \annot{\tau'}{\alpha'}$}
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
   \begin{smathpar}
      \inferrule*[
         left={\ruleName{$\unlookupR{}$-pair}},
         right={$v_1^\dagger, \sigma^\dagger \lookupR \rho_1', \tau^\dagger$}
      ]
      {
        \rho_2, \annot{\iota}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime} \unlookupR{v_2^\dagger, \tau^\dagger} u_2', \tau'
        \\
        \rho_1, \annot{\tau'}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime} \unlookupR{v_1^\dagger, \sigma^\dagger} u_1', \sigma'
      }
      {
        \rho_1 \concat \rho_2, \annot{\iota}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime}
        \unlookupR{\exPair{v_1^\dagger}{v_2^\dagger}, \trieProd{\sigma^\dagger}}
        \annot{\exPair{u_1'}{u_2'}}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime}, \trieProd{\sigma'}
      }
   \end{smathpar}
}
&
\text{\defref{unmatch}}
\notag
\\
&
\qedLocal
\annot{\exPair{u_1'}{u_2'}}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime}, \trieProd{\sigma'}
\leq
\annot{\exPair{u_1}{u_2}}{\alpha}, \trieProd{\sigma}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-roll}}]
   {
      u, \tau \lookupR \rho, \annot{\iota}{\alpha'}
   }
   {
      \annot{(\exRoll{u})}{\alpha}, \trieRoll{\sigma} \lookupR \rho, \annot{\iota}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-roll}}]
   {
     \rho, \annot{\iota}{\alpha \wedge \alpha'} \unlookupR{v^\dagger, \tau^\dagger} u', \sigma'
   }
   {
     \rho, \annot{\iota}{\alpha \wedge \alpha'}
     \unlookupR{\exRoll{v^\dagger}, \trieRoll{\sigma^\dagger}}
     \annot{(\exRoll{u'})}{\alpha \wedge \alpha'}, \trieRoll{\sigma'}
   }
\end{smathpar}
}
&
\text{
   IH; $\annot{\iota}{\alpha \wedge \alpha'} \leq \annot{\iota}{\alpha'}$
}
\notag
\\
&
\indent
u', \sigma' \leq u, \sigma
&
\text{$\unlookupR{}$ monotone}
\notag
\\
&
\qedLocal
\annot{(\exRoll{u'})}{\alpha \wedge \alpha'}, \trieRoll{\sigma'}
\leq
\annot{(\exRoll{u})}{\alpha}, \trieRoll{\sigma'}
&
\notag
\\
\intertext{\textbf{Part (ii)}}
&
\rho, \kappa \leq \rho^\dagger, \kappa^\dagger
&
\text{suppose ($\rho, \kappa$)}
\notag
\\
\intertext{Subgoal:}
&
\rho, \kappa \mathrel{\unlookupR{u^\dagger, \sigma^\dagger}\lookupR\geq} \rho, \kappa
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-var}}]
   {
     \strut
   }
   {
     \envExtend{\envEmpty}{x}{u}, \kappa
     \unlookupR{v, \trieVar{x}{\kappa^\dagger}}
     u, \trieVar{x}{\kappa}
   }
\end{smathpar}
}
&
\text{exists ($x, u$)}
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-var}}]
   {
      \strut
   }
   {
      u, \trieVar{x}{\kappa}
      \lookupR
      \envExtend{\envEmpty}{x}{u}, \kappa
   }
\end{smathpar}
}
&
\text{\defref{match}}
\notag
\\
&
\qedLocal
\envExtend{\envEmpty}{x}{u}, \kappa \geq \envExtend{\envEmpty}{x}{u}, \kappa
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-unit}}]
   {
     \strut
   }
   {
     \envEmpty, \annot{\iota}{\alpha}
     \unlookupR{\exUnit, \trieUnit{\kappa^\dagger}}
     \annot{\exUnit}{\alpha}, \trieUnit{\annot{\iota}{\alpha}}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-unit}}]
   {
      \strut
   }
   {
      \annot{\exUnit}{\alpha}, \trieUnit{\annot{\iota}{\alpha}}
      \lookupR
      \envEmpty, \annot{\iota}{\alpha \wedge \alpha}
   }
\end{smathpar}
}
&
\text{\defref{match}}
\notag
\\
&
\qedLocal
\envEmpty, \annot{\iota}{\alpha \wedge \alpha} \geq \envEmpty, \annot{\iota}{\alpha}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-inl}}]
   {
     \rho, \annot{\iota}{\alpha} \unlookupR{v^\dagger, \sigma^\dagger} u, \sigma
   }
   {
     \rho, \annot{\iota}{\alpha}
     \unlookupR{\exInl{v^\dagger}, \trieSum{\sigma^\dagger}{\tau^\dagger}}
     \annot{(\exInl{u})}{\alpha}, \trieSum{\sigma}{\annot{\tau}{\bot}}
   }
\end{smathpar}
}
&
\notag
\\
&
u, \sigma \lookupR \rho', \annot{\iota'}{\alpha'} \geq \rho, \annot{\iota}{\alpha}
&
\text{IH; exists ($\rho', \iota', \alpha'$)}
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-inl}}]
   {
      u, \sigma \lookupR \rho', \annot{\iota'}{\alpha'}
   }
   {
      \annot{(\exInl{u})}{\alpha}, \trieSum{\sigma}{\annot{\tau}{\bot}}
      \lookupR \rho', \annot{\iota'}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\text{\defref{match}}
\notag
\\
&
\qedLocal
\rho', \annot{\iota'}{\alpha \wedge \alpha'} \geq \rho, \annot{\iota}{\alpha}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-inr}}]
   {
     \rho, \annot{\iota}{\alpha} \unlookupR{v^\dagger, \tau^\dagger} u, \tau
   }
   {
     \rho, \annot{\iota}{\alpha}
     \unlookupR{\exInr{v^\dagger}, \trieSum{\sigma^\dagger}{\tau^\dagger}}
     \annot{(\exInr{u})}{\alpha}, \trieSum{\annot{\sigma}{\bot}}{\tau}
   }
\end{smathpar}
}
&
\notag
\\
&
u, \tau \lookupR \rho', \annot{\iota'}{\alpha'} \geq \rho, \annot{\iota}{\alpha}
&
\text{IH; exists ($\rho', \iota', \alpha'$)}
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-inr}}]
   {
      u, \sigma \lookupR \rho', \annot{\iota'}{\alpha'}
   }
   {
      \annot{(\exInr{u})}{\alpha}, \trieSum{\annot{\sigma}{\bot}}{\tau}
      \lookupR \rho', \annot{\iota'}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\text{\defref{match}}
\notag
\\
&
\qedLocal
\rho', \annot{\iota'}{\alpha \wedge \alpha'} \geq \rho, \annot{\iota}{\alpha}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[
      left={\ruleName{$\unlookupR{}$-pair}},
      right={$v_1^\dagger, \sigma^\dagger \lookupR \rho_1^\dagger, \tau^\dagger$}
   ]
   {
     \rho_2, \annot{\iota}{\alpha} \unlookupR{v_2^\dagger, \tau^\dagger} u_2, \tau
     \\
     \rho_1, \annot{\tau}{\alpha} \unlookupR{v_1^\dagger, \sigma^\dagger} u_1, \sigma
   }
   {
     \rho_1 \concat \rho_2, \annot{\iota}{\alpha}
     \unlookupR{\exPair{v_1^\dagger}{v_2^\dagger}, \trieProd{\sigma^\dagger}}
     \annot{\exPair{u_1}{u_2}}{\alpha}, \trieProd{\sigma}
   }
\end{smathpar}
}
&
\notag
\\
&
\indent
u_2, \tau \lookupR \rho_2', \annot{\iota'}{\alpha^\twoPrime}
\geq
\rho_2, \annot{\iota}{\alpha}
&
\text{IH; exists ($\rho_2', \iota', \alpha^\twoPrime$)}
\notag
\\
&
\indent
u_1, \sigma \lookupR \rho_1', \annot{\tau'}{\alpha'}
\geq
\rho_1, \annot{\tau}{\alpha}
&
\text{IH; exists ($\rho_2', \iota', \alpha'$)}
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-pair}}]
   {
      u_1, \sigma \lookupR \rho_1', \annot{\tau'}{\alpha'}
      \\
      u_2, \tau \lookupR \rho_2', \annot{\iota'}{\alpha^\twoPrime}
   }
   {
      \annot{\exPair{u_1}{u_2}}{\alpha}, \trieProd{\sigma}
      \lookupR
      \rho_1' \concat \rho_2', \annot{\iota'}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime}
   }
\end{smathpar}
}
&
\notag
\\
&
\qedLocal
\rho_1' \concat \rho_2', \annot{\iota'}{\alpha \wedge \alpha' \wedge \alpha^\twoPrime}
\geq
\rho_1 \concat \rho_2, \annot{\iota}{\alpha}
&
\notag
\\
&
\caseDerivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\unlookupR{}$-roll}}]
   {
     \rho, \annot{\iota}{\alpha} \unlookupR{v^\dagger, \sigma^\dagger} u, \sigma
   }
   {
     \rho, \annot{\iota}{\alpha}
     \unlookupR{\exRoll{v^\dagger}, \trieRoll{\sigma^\dagger}}
     \annot{(\exRoll{u})}{\alpha}, \trieRoll{\sigma}
   }
\end{smathpar}
}
&
\notag
\\
&
u, \sigma \lookupR \rho', \annot{\iota'}{\alpha'} \geq \rho, \annot{\iota}{\alpha}
&
\text{IH; exists ($\rho', \iota', \alpha'$)}
\notag
\\
&
\qedLocal
\derivation{\derivationWidth}{
\begin{smathpar}
   \inferrule*[left={\ruleName{$\lookupR$-non-var/$\lookupR$-roll}}]
   {
      u, \sigma \lookupR \rho', \annot{\iota'}{\alpha'}
   }
   {
      \annot{(\exRoll{u})}{\alpha}, \trieRoll{\sigma}
      \lookupR \rho', \annot{\iota'}{\alpha \wedge \alpha'}
   }
\end{smathpar}
}
&
\text{\defref{match}}
\notag
\\
&
\qedLocal
\rho', \annot{\iota'}{\alpha \wedge \alpha'} \geq \rho, \annot{\iota}{\alpha}
&
\notag
\end{flalign}
\end{proof}
