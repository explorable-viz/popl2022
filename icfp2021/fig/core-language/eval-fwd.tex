\begin{figure}[H]
\flushleft \shadebox{$\evalFwd{\rho}{e}{\alpha}{T}{v}$}
\begin{smathpar}
   \inferrule*[
      lab={\ruleName{$\evalFwdS$-var}}
   ]
   {
      e \eq \exVar{x}
      \\
      \envLookup{\rho}{x}{v}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trVar{x}{\Gamma}}{v}
   }
   %
   \and
   %
   \inferrule*[
      lab={\ruleName{$\evalFwdS$-op}}
   ]
   {
      e \eq \exOp{\primOp}
      \\
      \envLookup{\rho}{\primOp}{v}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trOp{\primOp}{\Gamma}}{v}
   }
   %
   \and
   %
   \inferrule*[lab={\ruleName{$\evalFwdS$-lambda}}]
   {
      e \eq \exLambda{\sigma}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trLambda{\sigma'}}{\exClosure{\rho}{\seqEmpty}{\sigma}}
   }
   %
   \and
   %
   \inferrule*[lab={\ruleName{$\evalFwdS$-int}}]
   {
      e \eq \annInt{n}{\alpha}
   }
   {
      \evalFwd{\rho}{e}{\alpha'}{\trInt{n}{\Gamma}}{\annInt{n}{\alpha \meet \alpha'}}
   }
   %
   \and
   %
   \inferrule*[lab={\ruleName{$\evalFwdS$-nil}}]
   {
      e \eq \annNil{\alpha}
   }
   {
      \evalFwd{\rho}{e}{\alpha'}{\trNil{\Gamma}}{\annNil{\alpha \meet \alpha'}}
   }
   %
   \and
   %
   \inferrule*[
      lab={\ruleName{$\evalFwdS$-cons}},
   ]
   {
      e \eq \annCons{e_1}{e_2}{\alpha}
      \\
      \evalFwd{\rho}{e_1}{\alpha'}{T}{v_1}
      \\
      \evalFwd{\rho}{e_2}{\alpha'}{U}{v_2}
   }
   {
      \evalFwd{\rho}{e}{\alpha'}{\trCons{T}{U}}{\annCons{v_1}{v_2}{\alpha \meet \alpha'}}
   }
   %
   \and
   %
   \inferrule*[lab={\ruleName{$\evalFwdS$-vector}}]
   {
      e \eq \annVec{e_1}{x}{e_2}{\alpha}
      \\
      \evalFwdEq{\rho}{e_2}{\alpha'}{T}
                {\annPair{\annInt{\ihat}{\smash{\gamma}}}{\annInt{\jhat}{\smash{\gamma'}}}{\beta}}
      \\
      \evalFwd{\rho \concat \bind{x}{i_{\gamma}} \concat \bind{y}{j_{\gamma'}}}{e_1}{\alpha'}{U_{i,j}}{v_{i,j}}
      \quad
      (\forall (i,j) \numleq (\ihat,\jhat))
   }
   {
      \evalFwd{\rho}{e}{\alpha'}{\trMatrix{U_{i,j}}{x}{y}{i}{j}{T}{\ihat,\jhat}}
              {\annMatrix{v_{i,j}}{i}{j}{(\annInt{\ihat}{\gamma},\annInt{\jhat}{\gamma'})}{\alpha \meet \alpha'}}
   }
   %
   \and
   %
   \inferrule*[
      lab={\ruleName{$\evalFwdS$-matrix-lookup}},
      right={$(i,j) \numleq (\ihat,\jhat)$}
   ]
   {
      e \eq \exMatrixAccess{e_1}{e_2}
      \\
      \evalFwdEq{\rho}{e_1}{\alpha}{T}
                {\annMatrix{v_{i,j}}{i}{j}{(\annInt{\ihat}{\gamma},\annInt{\jhat}{\gamma'})}{\beta}}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trMatrixAccess{T}{\ihat,\jhat}{U}{i,j}}{v_{i,j}}
   }
   %
   \and
   %
   \inferrule*[lab={\ruleName{$\evalFwdS$-matrix-dims}}]
   {
      e \eq \exMatrixDims{e'}
      \\
      \evalFwdEq{\rho}{e'}{\alpha'}{T}
                {\annot{\exMatrix{v_{i,j}}{i}{j}{(\annInt{\ihat}{\gamma},\annInt{\jhat}{\gamma'})}}{\beta}}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trMatrixDims{T}{\ihat,\jhat}}
              {\annPair{\annInt{\ihat}{\gamma}}{\annInt{\jhat}{\gamma'}}{\beta}}
   }
   %
   \and
   %
   \inferrule*[
      lab={\ruleName{$\evalFwdS$-apply}}
   ]
   {
      e \eq \exApp{e_1}{e_2}
      \\
      \evalFwdEq{\rho}{e_1}{\alpha}{T}{\exClosureRec{\Gamma}{\rho_1}{h}{\sigma}}
      \\
      \rho_1, \delta \closeDefs \rho_2
      \\
      \evalFwd{\rho}{e_2}{\alpha}{U}{v}
      \\
      v, w, \sigma \matchFwdS \rho_3, e', \beta
      \\
      \evalFwd{\rho_1 \concat \rho_2 \concat \rho_3}{e'}{\beta}{T'}{v'}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trApp{T}{U}{\matchPlug{w}{T'}}}{v'}
   }
   %
   \and
   %
   \inferrule*[lab={\ruleName{$\evalFwdS$-apply-prim}}]
   {
      e \eq \exApp{e_1}{e_2}
      \\
      \evalFwd{\rho}{e_1}{\alpha}{T}{\phi}
      \\
      \evalFwd{\rho}{e_2}{\alpha}{U}{\annInt{n}{\beta}}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trAppPrim{T}{\phi}{U}{\exInt{n}}}
              {\annot{\phi(n)}{\beta}}
   }
   %
   \and
   %
   \inferrule*[lab={
      \ruleName{$\evalFwdS$-let-rec}}
   ]
   {
      e \eq \exLetRecMutual{h}{e'}
      \\
      \rho_1, h \closeDefs \rho_2
      \\
      \evalFwd{\rho_1 \concat \rho_2}{e'}{\alpha}{T}{v}
   }
   {
      \evalFwd{\rho}{e}{\alpha}{\trLetRecMutual{h}{T}}{v}
   }
\end{smathpar}
\caption{Evaluation: forward slicing (Boolean and pair cases omitted)}
\end{figure}
