\begin{figure}[H]
\begin{syntaxfig}
\mbox{Surface term}
&
s
&
::=
&
...
&
\\
&&&
\exLetRecEquational{f}{\vec{c}}{s}
&
\text{recursive function}
\\
&&&
\exIfThenElse{s}{s}{s}
&
\text{if}
\\
&&&
\exMatch{s}{\smash{\overrightarrow{\clauseUncurried{p}{\smash{s}}}}}
&
\text{match}
\\
&&&
\exLet{p}{s}{s}
&
\text{structured let}
\\
&&&
\annList{s}{l}{\alpha}
&
\text{non-empty list}
\\
&&&
\exListSeq{s}{s}
&
\text{list enum}
\\
&&&
\annListComp{s}{\vec{q}}{\alpha}
&
\text{list comprehension}
\\[2mm]

\mbox{List rest}
&
l
&
::=
&
\hole
&
\text{hole}
\\
&&&
\annListEnd{\alpha}
&
\text{end}
\\
&&&
\annListNext{s}{l}{\alpha}
&
\text{cons}
\\[2mm]

\mbox{Clause}
&
c
&
::=
&
\clause{p}{s}
\\[2mm]

\mbox{Pattern or list rest pattern}
&
\pi
&
::=
&
p
&
\text{pattern}
\\
&&&
o
&
\text{list rest pattern}
\\[2mm]

\mbox{Pattern}
&
p
&
::=
&
\pattVar{x}
&
\text{variable}
\\
&&&
\pattNil
&
\text{nil}
\\
&&&
\pattCons{p}{p}
&
\text{cons}
\\
&&&
\pattList{p}{o}
&
\text{non-empty list}
\\
&&&
\pattPair{p}{p}
&
\text{pair}
\\[2mm]

\mbox{List rest pattern}
&
o
&
::=
&
\pattSNil
&
\text{end}
\\
&&&
\pattSCons{p}{o}
&
\text{cons}
\\[2mm]

\mbox{Qualifier}
&
q
&
::=
&
\annot{(\qualGuard{s})}{\alpha}
&
\text{guard}
\\
&&&
\annot{(\qualDeclaration{p}{s})}{\alpha}
&
\text{declaration}
\\
&&&
\annot{(\qualGenerator{p}{s})}{\alpha}
&
\text{generator}
\\[2mm]

\end{syntaxfig}
\caption{Syntax of surface-language terms ($\vec{\param}$ denotes non-empty sequence)}
\end{figure}
