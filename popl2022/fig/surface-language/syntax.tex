\begin{figure}[H]
\begin{syntaxfig}
\mbox{Identifier}
&
x, y
&
::=
&
\ldots
\\
&&&
\primOp
&
\text{operator name}
\\
\mbox{Surface term}
&
s, t
&
::=
&
\ldots
&
\\
&&&
\exOp{\primOp}
&
\text{first-class operator}
\\
&&&
\exBinaryApp{s}{\primOp}{s'}
&
\text{binary application}
\\
&&&
\exLetRecMutual{\vec{g}}{s}
&
\text{mutually recursive functions}
\\
&&&
\exIfThenElse{s}{s}{s}
&
\text{if}
\\
&&&
\exMatch{s}{\vec{\clauseUncurried{p}{s}}}
&
\text{match}
\\
&&&
\exLet{p}{s}{s}
&
\text{structured let}
\\
&&&
\annList{s}{r}{\alpha}
&
\text{non-empty list}
\\
&&&
\exListEnum{s}{s}
&
\text{list enum}
\\
&&&
\annListComp{s}{\vec{q}}{\alpha}
&
\text{list comprehension}
\\[2mm]

\mbox{List rest term}
&
r
&
::=
&
\annListEnd{\alpha}
&
\text{end}
\\
&&&
\annListNext{s}{r}{\alpha}
&
\text{cons}
\\[2mm]

\mbox{Recursive function}
&
g
&
::=
&
\bind{x}{\vec{c}}
\\[2mm]

\mbox{Clause}
&
c
&
::=
&
\clause{\vec{p}}{s}
\\[2mm]

\mbox{Pattern}
&
p
&
::=
&
\pattVar{x}
&
\text{variable}
\\
&&&
\pattRec{\vec{\bind{x}{p}}}
&
\text{record}
\\
&&&
\pattNil
&
\text{nil}
\\
&&&
\pattCons{p}{p}
&
\text{cons}
\\
&&&
\pattList{p}{o}
&
\text{non-empty list}
\\[2mm]

\mbox{List rest pattern}
&
o
&
::=
&
\pattListEnd
&
\text{end}
\\
&&&
\pattListNext{p}{o}
&
\text{cons}
\\[2mm]

&
\pi
&
::=
&
p \mid o
\\[2mm]

\mbox{Qualifier}
&
q
&
::=
&
\qualGuard{s}
&
\text{guard}
\\
&&&
\qualDeclaration{p}{s}
&
\text{declaration}
\\
&&&
\qualGenerator{p}{s}
&
\text{generator}
\end{syntaxfig}
\caption{Syntax of surface-language terms}
\end{figure}
