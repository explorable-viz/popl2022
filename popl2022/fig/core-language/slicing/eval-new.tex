\begin{figure}[H]
\small
$\begin{array}{lll|llll}
&&&\textit{where}
\\
\arrayrulecolor{lightgray}
\rowcolor{verylightgray}
\evalFwdF{T} &::& \Below{(\rho,e,\TT)} \to \Below{v}
&T &::& \rho, e \evalR v
\\
% hole
\evalFwdF{T}(\rho,e,\alpha)
&=&
\evalFwdF{T}(\rho',e',\alpha)
&
(\rho, e) &\eq& (\rho',e')
\\
% var
\smash{\evalFwdF{\trVar{x}{\rho}}(\rho',\exVar{x},\alpha)}
&=&
\envLookupFwdF{\rho,x}(\rho',x)
\\
% lambda
\evalFwdF{\trLambda{\sigma'}}(\rho,\exLambda{\sigma},\alpha)
&=&
\exClosure{\rho}{\seqEmpty}{\sigma}
\\
% int
\evalFwdF{\trInt{n}{\rho}}(\rho',\annInt{n}{\alpha'},\alpha)
&=&
\annInt{n}{\alpha \meet \alpha'}
\\
% record
\evalFwdF{\trRec{\vec{\bind{x}{T}}}}(\rho,\annRec{\vec{\bind{x}{e}}}{\alpha},\alpha')
&=&
\annRec{\vec{\bind{x}{v}}}{\alpha \meet \alpha'}
&
v_i &=& \evalFwdF{T_i}(\rho, e_i, \alpha')
\\
% project
\evalFwdF{\trRecProj{T}{\vec{x}}{x_i}}(\rho,\exRecProj{e}{x},\alpha)
&=&
v_i
&
\exRec{\vec{\bind{x}{v}}} &=& \evalFwdF{T}(\rho, e, \alpha)
\\
% nil
\evalFwdF{\trNil{\rho}}(\rho',\annNil{\alpha'},\alpha)
&=&
\annNil{\alpha \meet \alpha'}
\\
% cons
\evalFwdF{\trCons{T}{U}}(\rho,\annCons{e_1}{e_2}{\alpha'},\alpha)
&=&
\annCons{v_1}{v_2}{\alpha \meet \alpha'}
&
v_1 &=& \evalFwdF{T}(\rho, e_1, \alpha)
\\
&&&
v_2 &=& \evalFwdF{U}(\rho, e_2, \alpha)
\\
% apply-prim
\smash{\evalFwdF{\trAppPrim{T}{\phi}{\vec{n}}{U}{\exInt{m}}}(\rho,\exApp{e_1}{e_2},\alpha)}
&=&
\primFwd{\phi}{\vec{n} \concat m}(\vec{v} \concat u)
&
\exPrimOp{\phi}{\vec{v}} &\eq& \evalFwdF{T}(\rho, e_1, \alpha)
\\
&&&
u &=& \evalFwdF{U}(\rho, e_2, \alpha)
\\
% apply
\evalFwdF{\trApp{T}{U}{w}{T'}}(\rho',\exApp{e_1}{e_2},\alpha) % {\rho}{h}
&=&
\evalFwdF{T'}(\rho_1 \concat \rho_2 \concat \rho_3, e', \beta)
&
\exClosure{\rho_1}{h'}{\sigma} &\eq& \evalFwdF{T}(\rho',e_1,\alpha)
\\
&&&
\rho_2 &=& \closeDefsFwdF{\rho,h}(\rho_1, h')
\\
&&&
v &=& \evalFwdF{U}(\rho',e_2,\alpha)
\\
&&&
(\rho_3,e',\beta) &=& \matchFwdF{w}(v,\sigma)
\\
% let-rec
\evalFwdF{\trLetRecMutual{\rho}{T}}(\rho',\exLetRecMutual{h'}{e'},\alpha) % {h}
&=&
\evalFwdF{T}(\rho' \concat \rho_1,e,\alpha)
&
\rho_1 &=& \closeDefsFwdF{\rho,h}(\rho', h')
\end{array}$
\vspace{3mm}

$\begin{array}{lll|llll}
\arrayrulecolor{lightgray}
\rowcolor{verylightgray}
\evalBwdF{T} &::& \Below{v} \to \Below{(\rho,e,\TT)}
&T &::& \rho, e \evalR v
\\
% hole
\evalBwdF{T}(v)
&=&
\evalBwdF{T}(u)
&
v \eq u
\\
% var
\evalBwdF{\trVar{x}{\rho}}(v)
&=&
(\envLookupBwdF{\rho,x}(v),\exVar{x},\FF)
\\
% fun
\evalBwdF{\trLambda{\sigma'}}(\exClosure{\rho}{\seqEmpty}{\sigma})
&=&
(\rho,\exLambda{\sigma},\FF)
\\
% int
\evalBwdF{\trInt{n}{\rho}}(\annInt{n}{\alpha})
&=&
(\holeEnv{\rho},\annInt{n}{\alpha},\alpha)
\\
% nil
\evalBwdF{\trNil{\rho}}(\annNil{\alpha})
&=&
(\holeEnv{\rho},\annNil{\alpha},\alpha)
\\
% record
\evalBwdF{\trRec{\vec{\bind{x}{T}}}}(\annRec{\vec{\bind{x}{v}}}{\alpha})
&=&
(\bigjoin\vec{\rho}, \annRec{\vec{\bind{x}{e}}}{\alpha}, \alpha \join \bigjoin\vec{\alpha}')
&
(\rho_i, e_i, \alpha_i') &=& \evalBwdF{T_i}(v_i)
\\
% project
\evalBwdF{\trRecProj{T}{\vec{x}}{x_i}}(v)
&=&
(\rho, \exRecProj{e}{x_i}, \alpha)
&
(\rho, e, \alpha) &=& \evalBwdF{T}(\annRec{\mapUpdate{\vec{\bind{x}{\hole}}}{x_i}{v}}{\FF})
\\
% cons
\evalBwdF{\trCons{T}{U}}(\annCons{v_1}{v_2}{\beta})
&=&
(\rho \join \rho', \annCons{e_1}{e_2}{\beta}, \beta^\twoPrime)
&
(\rho,e_1,\alpha) &=& \evalBwdF{T}(v_1)
\\
&&&
(\rho',e_2,\alpha') &=& \evalBwdF{U}(v_2)
\\
&&&
\beta^\twoPrime &=& \beta \join \alpha \join \alpha'
\\
% apply-prim
\evalBwdF{\trAppPrim{T}{\phi}{\vec{n}}{U}{\exInt{m}}}(v)
&=&
(\rho \join \rho', \exApp{e_1}{e_2}, \alpha \join \alpha')
&
\primBwd{\phi}{\vec{n} \concat m}(v) &=& \vec{u} \concat u'
\\
&&&
(\rho,e_1,\alpha) &=& \evalBwdF{T}(\exPrimOp{\phi}{\vec{u}})
\\
&&&
(\rho',e_2,\alpha') &=& \evalBwdF{U}(u')
\\
% apply
\evalBwdF{\trApp{T}{U}{w}{T'}}(v)
&=&
(\rho \join \rho', \exApp{e_1}{e_2}, \alpha \join \alpha')
&
(\rho_1 \concat \rho_2 \concat \rho_3, e, \beta) &=& \evalBwdF{T'}(v)
\\
&&&
(v', \sigma) &=& \matchBwdF{w}(\rho_3,e,\beta)
\\
&&&
(\rho,e_2,\alpha) &=& \evalBwdF{U}(v')
\\
&&&
(\rho_1', h) &=& \closeDefsBwdF{}(\rho_2)
\\
&&&
(\rho',e_1,\alpha') &=& \evalBwdF{T}(\exClosure{\rho_1 \join \rho_1'}{h}{\sigma})
\\
% let-rec
\evalBwdF{\trLetRecMutual{h}{T}}(v)
&=&
(\rho \join \rho',\exLetRecMutual{h'}{e},\alpha)
&
(\rho \concat \rho_1,e,\alpha) &=& \evalBwdF{T}(v){T}
\\
&&&
(\rho', h') &=& \closeDefsBwdF{}(\rho_1)
\end{array}$
\caption{Evaluation: forward and backward dependency (Boolean cases omitted)}
\label{fig:eval:bwd}
\end{figure}
