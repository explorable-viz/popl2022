\newpage

\section{A core language for fine-grained data dependencies}
\label{sec:core-language}

To show how we achieve a system of fine-grained dependency tracking between structured outputs and inputs, we first introduce the core calculus for our language and then describe how we can enrich this language with annotations that support the notion of selection. This notion of selection will allow us to link output values to input values and program fragments reponsible for constructing these output values. This core language will serve as the target for which the surface language in Section \ref{sec:surface-language} desugars into.

\subsection{Syntax and typing}

\subsubsection{Typing}
We begin by introducing the types $A$ of our language in Figure \ref{fig:core-syntax-type}. These consist of primitive types Booleans $\tyBool$, integers $\tyInt$, and function types $\tyFun{A}{B}$, but additionally lists $\tyList{A}$, vectors $\tyVec{A}$, and records $\tyRec{\vec{\bind{x}{A}}}$ in order to support the kind of fine-grained relationships between input and output typically found in modern programs. The notation $\seq{\bind{x}{A}}$ represents a sequence of bindings of variables $x$ to types $A$.
\input{fig/core-language/syntax-type}


\subsubsection{Terms}
Next we describe the terms of our language as defined in Figure \ref{fig:core-syntax-term}.  These include Boolean constants $\exTrue$ and $\exFalse$, integers $n$, variables $x$, and applications $\exApp{e}{e'}$. We also provide empty lists $\exNil$ and non-empty lists $\exCons{e}{e'}$, vectors $\exVec{e}{x}{e'}$ which are constructed in a comprehension-like notation, and records $\exRec{\vec{\bind{x}{e}}}$ as a sequence of bindings between field names and terms. We include operations for vector lookups $\exVecLookup{e}{e'}$, vector length $\exVecLen{e}$, and record projection $\exRecProj{e}{x}$ for projecting a field $x$ out of the record given by $e$. The final two terms, namely anonymous functions, $\exLambda{\sigma}$, and recursive let-bindings, $\exLetRecMutual{h}{e}$ where $h$ is of the form $\vec{\bind{x}{\sigma}}$, will be explained in \ref{sssec:syntax-eliminator-terms} once we have introduced the idea of an eliminator $\sigma$ which is the only elimination form provided by the core language. Our implementation is untyped but we give typing rules for clarity; the typing rules for terms are given in Figure \ref{fig:core-typing-term} and are straightforward except for those containing eliminators.

 %% for anonymous functions $\exLambda{\sigma}$ and recursive let-bindings $\exLetRecMutual{h}{e}$. We again ask the reader to defer to Section \ref{sssec:syntax-eliminator} and \ref{sssec:syntax-eliminator-terms}. It should be noted that our implementation does not implement typing rules, but we give them for the sake of clarity.

\input{fig/core-language/syntax-term}

\noindent

\subsubsection{Eliminators}
\label{sssec:syntax-eliminator}
Eliminators $\sigma$ are defined in Figure \ref{fig:core-syntax-term}. Intuitively, an eliminator specifies how to match against a partial value of some type and selects a continuation $\kappa$ for further execution, where $\kappa$ is either a term $e$ or another eliminator $\sigma$. The variable eliminator $\elimVar{x}{\kappa}$ matches against any value, binds it to $x$, and then continues as $\kappa$. The Boolean eliminator $\elimBool{\kappa}{\kappa'}$ selects either $\kappa$ or $\kappa'$ depending on whether the boolean value is $\exTrue$ or $\exFalse$. The record eliminator $\elimRec{\seq{x}}{\kappa}$ matches a record with fields $\seq{x}$ and then continues as $\kappa$ with the variables $\seq{x}$ bound to the components of the record. Finally, the list eliminator $\elimList{\kappa}{\sigma}$ maps the empty list to $\kappa$ and a non-empty list to another eliminator $\sigma$ which specifies how the head and tail of the list are to be matched. Eliminators resemble the ``case trees'' commonly used as an intermediate form when compiling languages with pattern-matching \cite{graf20}, and can serve as an elaboration target for more advanced features such as the piecewise definitions described in Section \ref{sec:surface-language}.

The use of nested eliminators to represent demand on sub-values means that, formally, eliminators correspond to Hinze's notion of generalized tries \cite{hinze00} extended with variable bindings. This will become clearer if we consider the typing judgement $\Gamma \vdash \sigma: \tyFun{A}{B}$ for eliminators given in Figure \ref{fig:core-typing-term}. The typing rule for variable eliminators reveals the connection between eliminators and functions: it converts a continuation $\kappa$ which can be assigned type $B$ under the assumption that $x$ is of type $A$ into an eliminator of type $\tyFun{A}{B}$. The typing rule for Boolean eliminators says that to make an eliminator of type $\tyFun{\tyBool}{A}$, we simply need two continuations $\kappa$ and $\kappa'$ of type $A$. 

% A common alternative to this is to use case-expressions, however, real-world functional languages have rich pattern-matching features such as piecewise definitions, view patterns, pattern synonyms, etc with non-trivial exhaustiveness-checking rules. Instead, we want an efficient, simple core pattern-matching feature that is total by construction and can serve as an elaboration target for more advanced features. In Section \ref{sec:surface-language} we show how to desugar piecewise definitions that satisfy certain well-formedness conditions into eliminators. 

%We explain the syntax of each eliminator (Figure \ref{fig:core-syntax-term}) and give insight on how they work in reference to their typing rules (Figure \ref{fig:core-typing-term}). 

\noindent

\subsubsection{Typing rules}
\label{sssec:typing-terms}

\input{fig/core-language/typing-term}

The boolean-eliminator $\elimBool{\kappa}{\kappa'}$, where $\kappa$ and $\kappa'$ have the same type $A$, maps the boolean value $\exTrue$ to the continuation $\kappa$ and $\exFalse$ to the continuation $\kappa'$. The eliminator $\elimBool{\kappa}{\kappa'}$ is hence a function of type $\tyFun{\tyBool}{A}$. 

A record-eliminator $\elimRec{\seq{x}}{\kappa}$ matches a record with fields $\seq{x}$ and then continues as $\kappa$, where $\kappa$ is typed in a context with a binding for each variable in $\seq{x}$. If $\seq{x}$ is empty with the form $\kw{()}$, then $\kappa$ is typed with no additional bindings. If $\seq{x}$ is non-empty with the form $\vec{x} \concat y$, then the continuation $\kappa$ is necessarily another eliminator $\sigma$ with a curried type which matches a record of type $\tyRec{\vec{\bind{x}{A}}}$ and maps it to an eliminator of type $\tyFun{A'}{B}$. The rule for non-empty records allows us to equivalently treat an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}}}}{\tyFun{A'}{B}}$ as an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}} \concat \bind{y}{A'}}}{B}$ which matches against the same record but extended with another field $y$ of type $A'$. This can be viewed as the isomorphism between a function of type $\tyFun{\tyFun{A}{B}}{C}$ and a function of type $\tyFun{\tyProd{A}{B}}{C}$, but specialized to record types \cite{hinze00}. 

The final eliminator, the list-eliminator $\elimList{\kappa}{\sigma}$, combines some of the flavours of record and boolean eliminators. The first branch maps the empty list $\exNil$ to a continuation $\kappa$ of type $B$. The second branch maps the non-empty list constructor $(\symCons)$ to a curried eliminator $\sigma$ -- this eliminator then matches the head element of type $A$ and the rest of the list of type $\tyList{A}$, to return a type $B$.

As a last note, we give the typing rule for mutually recursive functions under judgement $\Gamma \vdash h: \Delta$, where $h = \vec{\bind{x}{\sigma}}$ is a sequence of function names bound to eliminators and $\Delta$ is a vector of variables bound to function types. This states that if all functions $\sigma_i$ are well-typed under the typing context $\Gamma \concat \Delta$, then the environment of mutually recursive functions $h$ is well-typed as $\Delta$ under context $\Gamma$.

\subsubsection{Syntax - Terms with eliminators}
\label{sssec:syntax-eliminator-terms}
Having introduced eliminators, we can revisit the terms our core-language which involve eliminators (Figure \ref{fig:core-syntax-term}) and their typing rules (Figure \ref{fig:core-typing-term}). Anonymous functions, $\exLambda{\sigma}$, allow us to inject eliminators $\sigma$ into terms by wrapping them in a constructor $\lambda$. This has no impact on the typing rules, hence $\sigma$ and $\exLambda{\sigma}$ have the same types. Recursive let-bindings are then denoted by $\exLetRecMutual{h}{e}$. Given that $h$ is a sequence of mutually recursive functions $\vec{\bind{x}{\sigma}}$ of type $\Delta$ (a vector of variables bound to function types) under context $\Gamma$, and $e$ has type $A$ in the context $\Gamma \concat \Delta$, then the entire term $\exLetRecMutual{h}{e}$ has type $A$ under context $\Gamma$. 

\subsubsection{Syntax - Values}
Before we move on to considering how to represent data selections, we describe the final part of the core syntax in Figure \ref{fig:core-syntax-value} for values. Firstly, the environment $\rho$ of a program consists of bindings between variables and values. The values $v$ which terms can then evaluate to include: booleans $\exTrue$ and $\exFalse$, integers $n$, empty $\exNil$ and non-empty lists $\exCons{u}{v}$, records $\exRec{\vec{\bind{x}{v}}}$, and vectors $\exVecVal{\vec{v}}{j}$ of values $\vec{v}$ with fixed-length $j$. Additionally, we have partially applied primitives $\exPrimOp{\phi}{\vec{v}}$ where $\phi$ is a primitive operation applied to an incomplete sequence of values $\vec{v}$, and function closures $\exClosure{\rho}{h}{\sigma}$ consisting of an environment $\rho$, a sequence of mutually recursive functions $h$, and eliminator $\sigma$. 
\input{fig/core-language/syntax-value}

\noindent
We follow this up with the typing rules for environments and values in Figure \ref{core-typing-value}. For environments, the judgement $\vdash \rho: \Gamma$ states that if all the values $v_i$ of the environment are well typed, then the environment itself is well-typed. 

The typing rules for values $\vdash v: A$ are self-explanatory for integers, booleans, records, lists, and vectors, but we elaborate on partially-applied primitives and closures. Given a primitive operation $\phi$ which takes $i+j$ integer arguments to output an integer, when partially applied to a sequence of $i$ integers this produces a function which takes $j$ more integers. The typing rule for closures $\exClosure{\rho}{h}{\sigma}$ then states that given its local environment $\rho$ has type $\Gamma$, its environment of mutually recursive functions $h$ has type $\Delta$ under context $\Gamma$, and its eliminator $\sigma$ has type $\tyFun{A}{B}$ under context $\Delta \concat \Gamma$, then the entire closure has type $\tyFun{A}{B}$.

\input{fig/core-language/typing-value}

\subsubsection{Annotated Values and Terms}

Now that the core calculus has been fully specified, this gives us a foundation to begin enriching our language to become suitable for tracking data dependencies. The first thing to establish is the notion of selection which is a way of selecting parts of the program of interest -- this is what will later allow us to perform data dependency analysis in Section \ref{sec:toolkit}. To do this, we first take all the first-order data forms and augment them with an annotation to indicate their selection state.

\input{fig/core-language/syntax-selection}

\noindent
To incorporate annotations in our calculus, we first take all the first-order data forms and augment them with an annotation to indicate the selection state. The syntax for annotations along with the annotated forms of our core-language are given in Figure \ref{fig:core-syntax-selection}. 

As we are primarily interested in tracking data dependencies between values, we first give the annotation-augmented form of values -- this includes: booleans, $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{v}}}{\alpha}$, empty lists $\annNil{\alpha}$ and non-empty lists $\annCons{u}{v}{\alpha}$, and vectors $\annVecVal{\vec{v}}{\annInt{j}{\alpha}}{\smash{\alpha'}}$. We also introduce holes $\hole$ as a special expression form that corresponds to annotating every position within a value with the bottom element of a lattice.

In order to then propagate the selection-state information of values back to the expressions of our our program which are responsible for creating them, we must also add annotations to the necessary expression forms of our language, $e$. These correspond to the annotated forms of values, and hence include: holes $\hole$, booleans, $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{e}}}{\alpha}$, empty lists $\annNil{\alpha}$ and non-empty lists $\annCons{e}{e'}{\alpha}$, and vectors $\annVec{e}{x}{e'}{\alpha}$.

Annotations allow us to think of the data type of terms and values as a functor which associates terms/values with selection information. It should be noted that the choice of annotation type is kept mostly abstract as there are various forms of selection information we may want to express in our language -- however, we rely on the assumption that annotations are required to be a lattice so that we can use the top element $\top$ of the lattice to represent selection and the bottom element $\bot$ to represent unselection. The most simple choice of lattice would be to set the type of annotations to be the trivial unit lattice -- this lets us recover the original unannotated syntax presented in Figure \ref{fig:core-syntax-term} and \ref{fig:core-syntax-value}. Most typically, one would use the boolean lattice to indicate a selection of true or false, however we can also use more sophisticated lattices such as a vector of booleans to represent multiple selections simultaneously.


\subsection{Evaluation}

With our core syntax, we can now move on to the semantics of how our language evaluates -- we explain this in two parts. First we give semantics to pattern matching and evaluation of terms \textit{without} annotations; for this, we must introduce a mechanism of recording the execution of a program during evaluation -- these are known as program traces. This will provide us the means to later describe how annotated terms in our program can propagate to annotated values in our output (and vice versa) through forward and backward dependency tracking rules in Section \ref{ssec:core-fwd-bwd}.

\subsubsection{Syntax - Traces}
\label{ssec:core-syntax-trace}

\input{fig/core-language/syntax-trace}

A trace $T$, shown in Figure \ref{fig:core-syntax-trace}, is a compact notation for the proof terms for the evaluation relations of our language, defined inductively in Figure \ref{fig:eval}. 
They closely mirror the terms of our language, and operationally are a means of recording the details of program execution and providing an explanation of how a result was computed \cite{perera12a}. Matches $w$ are then a specific form of trace used in the pattern matching relation defined in Figure $\ref{fig:core-match}$ -- it is used to record which pattern was matched against in an eliminator and hence which branch was taken during program execution. 



% Explain evaluation in a two-stage way like we did with syntax. First we give semantics to pattern matching evaluation and terms without annotation, and then we give forward and backward dependency tracking rules to propagate annotation for annotated terms. We also need to explain the idea of a trace T (a trace is what we refer to as "Match" and "Trace") - these are essentially a compact notation for the proof terms for the evaluation relations which are defined inductively in figure 13 (T :: p, e => v), and operationally are a means of recording the details of program execution. For this we can cite Roly's previous work (imperative functional programs and something else) - these two take a similar approach. Another way to do this would be to define the evaluation relation to additionally output a trace, but here we say that we define evaluation inductively as a relation, so the proof trees of that definition are the traces essentially. What the syntax in figure 11 (matches and traces) does is just define a more compact notation for proof trees for those relations. It's not so much that we compute traces during forward slicing, but that we need traces for forward slicing as well.

%. These are computed during forward slicing, and allows slicing to then proceed backwards afterwards.

\subsubsection{Semantics - Pattern matching}
\label{ssec:core-semantics-match}
\input{fig/core-language/match}

We first give a semantics to pattern matching in our language (Figure \ref{fig:core-match}) where the judgement $\explVal{w}{v, \sigma \matchR \rho, \kappa}$ states that matching a value $v$ against an eliminator $\sigma$ evaluates to an environment $\rho$ which binds $v$ to any matched variables in $\sigma$ and a continuation $\kappa$. The trace $\textcolor{gray}{w}$ witnesses which branch was taken.


\subsubsection{Semantics - Evaluation}
\label{ssec:core-semantics-eval}
\input{fig/core-language/eval}

Next we explain the semantics for evaluating terms in our language (Figure \ref{fig:eval}) where the judgement $\explVal{T}{\rho, e \evalR v}$ states that a term $e$ under environment $\rho$ evaluates to a value $v$. The trace $\textcolor{gray}{T}$ records the evaluation that occurs. 

\input{fig/core-language/eval-aux}

\begin{definition}
   \label{def:core-language:closeDefs}
   Define the relation $\closeDefsR$ as given in \figref{core-language:eval-aux}.
\end{definition}

\subsection{Forward and backward Galois dependency}
\label{ssec:core-fwd-bwd}
\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

\begin{definition}[Order on selection state]
   Define $\leq$ to be the total order satisfying $\FF \leq \alpha$ and $\TT \leq \TT$.
\end{definition}

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

\input{fig/core-language/slicing/join-value}
\input{fig/core-language/slicing/join-elim}

\subsubsection{Pattern-matching}

\input{fig/core-language/slicing/match-fwd}
\input{fig/core-language/slicing/match-bwd}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}

\subsubsection{Evaluation}

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\input{fig/core-language/slicing/eval-fwd}
\input{fig/core-language/slicing/eval-bwd}
\input{fig/core-language/slicing/eval-aux}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}
