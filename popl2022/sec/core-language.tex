\section{Core calculus}
\label{sec:core-language}

In this section we introduce the core calculus that will be the basis of the bidirectional analyses described in (\secref{data-dependencies}). This notion of selection will allow us to link output values to input values and program fragments reponsible for constructing these output values. This core language will serve as the target for which the surface language in \secref{surface-language} desugars into.
\todo{Revisit how well this introduces the structure of the section}

\subsection{Syntax and typing}
\label{sec:core-language:syntax-typing}

Although our implementation in untyped, types help describe the structure of the core language. \figref{fig:core-language:syntax} introduces the types $A, B$ which consist of primitive types $\tyBool$ and $\tyInt$ and function types $\tyFun{A}{B}$, but also lists $\tyList{A}$ and records $\tyRec{\vec{\bind{x}{A}}}$ which exemplify the two primary kinds of structured data we consider: lists represent data with a varying structure, and records represent data with a fixed shape. (Our implementation of the core language also supports matrices, which also have a fixed shape, so with omit these from the formalism.) The notation $\bind{x}{A}$ is not to be confused with the list constructor $\symCons$, and denotes the pair of $x$ and $A$ (understood as a binding); $\seq{\bind{x}{A}}$ denotes the sequence of bindings that results from zipping same-length sequences $\vec{x}$ and $\vec{A}$.

\input{fig/core-language/syntax}

The terms of the language are defined in \figref{core-language:syntax}. These include Boolean constants $\exTrue$ and $\exFalse$, integers $n$, variables $x$, and applications $\exApp{e}{e'}$. We also provide empty lists $\exNil$ and non-empty lists $\exCons{e}{e'}$, record construction $\exRec{\vec{\bind{x}{e}}}$ and record projection $\exRecProj{e}{x}$. The final two term forms, anonymous functions $\exLambda{\sigma}$ and recursive let-bindings $\exLetRecMutual{h}{e}$ where $h$ is of the form $\vec{\bind{x}{\sigma}}$, are explained below. First we introduce the elimination form $\sigma$, which we call an \emph{eliminator}. The typing rules for terms are given in \figref{fig:core-language:typing} and are straightforward except for those which refer to eliminators.

\subsection{Eliminators}
\label{sec:core-language:syntax-eliminator}
Eliminators $\sigma, \tau$ are also defined in \figref{core-language:syntax}, and are inspired by \citeauthor{connelly95}'s notion of generalised trie, elaborated further by \citet{hinze00}. Eliminators specify how to match against a partial value of some type and select a continuation $\kappa$ for further execution, where $\kappa$ is either a term $e$ or another eliminator $\sigma$. The Boolean eliminator $\elimBool{\kappa}{\kappa'}$ selects either $\kappa$ or $\kappa'$ depending on whether the boolean value is $\exTrue$ or $\exFalse$. The record eliminator $\elimRec{\seq{x}}{\kappa}$ matches a record with fields $\seq{x}$ and then returns $\kappa$ with the variables $\seq{x}$ bound to the components of the record. The list eliminator $\elimList{\kappa}{\sigma}$ maps the empty list to $\kappa$ and a non-empty list to another eliminator $\sigma$ which specifies how the head and tail of the list are to be matched. The variable eliminator $\elimVar{x}{\kappa}$ extends \citeauthor{connelly95}'s notion, matching any value, binding it to $x$, and then returning $\kappa$. Eliminators resemble the ``case trees'' commonly used as an intermediate form when compiling languages with pattern-matching \cite{graf20}, and can serve as an elaboration target for more advanced features such as the piecewise definitions described in \secref{sec:surface-language}.

The use of nested eliminators to represent demand on sub-values will become clearer if we consider the typing judgement $\Gamma \vdash \sigma: \tyFun{A}{B}$ for eliminators given in \figref{core-language:typing}. (Eliminators always have function type, so this should be read as a four-place relation, with $\to$ part of the notation.) The typing rule for variable eliminators reveals the connection between eliminators and functions: it converts a continuation $\kappa$ which can be assigned type $B$ under the assumption that $x$ is of type $A$ into an eliminator of type $\tyFun{A}{B}$. The typing rule for Boolean eliminators says that to make an eliminator of type $\tyFun{\tyBool}{A}$, we simply need two continuations $\kappa$ and $\kappa'$ of type $A$. The rule for the empty record states that to make an eliminator of type $\tyFun{\tyRec{}}{A}$, we simply need a continuation $\kappa$ of type $A$. The rule for non-empty records allows us to treat an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}}}}{\tyFun{A'}{B}}$ into an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}} \concat \bind{y}{A'}}}{B}$, representing the isomorphism between $\tyFun{\tyFun{A}{B}}{C}$ and $\tyFun{\tyProd{A}{B}}{C}$ but at the level of record types \cite{hinze00}. (Formalising eliminators thus requires \citeauthor{bird98}-style nested datatypes \cite{bird98} and polymorphic recursion, but these details need not concern us here.)

The typing rule for list eliminators $\elimList{\kappa}{\sigma}$ combines some of the flavour of record and Boolean eliminators. To make an eliminator of type $\tyFun{\tyList{A}}{B}$, we need a continuation of type $B$ for the empty case, and an eliminator of type $\tyFun{A}{\tyFun{\tyList{A}}{B}}$ which can be treated as an eliminator of type $\tyFun{\tyProd{A}{\tyList{A}}}{B}$ in order to process the head and tail in the non-empty case.

\subsubsection{Eliminators as functions}

We can now revisit the term forms $\exLambda{\sigma}$ and $\exLetRecMutual{h}{e}$. If $\sigma$ is an eliminator of type $\tyFun{A}{B}$, then $\exLambda{\sigma}$ is an anonymous function of the same type. If $h$ is of the form $\vec{\bind{x}{\sigma}}$, then $\exLetRecMutual{h}{e}$ introduces a sequence of mutually recursive functions which are in scope in $e$. The typing rule for $\exLetRecMutual{h}{e}$ uses an auxiliary typing judgement $\Gamma \vdash h : \Delta$ which assigns to every $x$ in $\Delta$ a function type $\tyFun{A}{B}$ as long as the $\sigma$ to which $x$ is bound in $h$ has that type.

\input{fig/core-language/typing}

\subsubsection{Values}
Values $v, u$, and environments $\rho$ are also defined in \figref{core-language:syntax}, and are standard for call-by-value. To support mutual recursion, the closure form $\exClosure{\rho}{h}{\sigma}$ captures the (possibly empty) sequence $h$ of functions with which the function was mutually defined, in addition to the ambient environment $\rho$. For the typing judgements $\vdash \rho: \Gamma$ and $\vdash v: A$ for environments and values (\figref{core-language:typing}), only the closure case is worth noting, which delegates to the typing rules for recursive definitions and eliminators.

\subsection{Semantics}

\figref{core-language:semantics} gives the operational semantics of the core language. Following the ``proved transitions'' approach of \citeauthor{boudol89} for reversible CC~ \cite{boudol89}, we treat the operations semantics as an inductive data type whose inhabitants represent executions. Because these proof terms can become quite cumbersome, we introduce a compact (term-like) syntax for them called \emph{traces} (\figref{core-language:syntax-trace}), similar to the approach taken by \citeauthor{perera16d} for $\pi$-calculus~\cite{perera16d}, that leave most of the indices implicit. Traces $T, U$ will be used in \secref{core-language:dependency-analysis} to define forward and backward analyses over a single execution.

\subsubsection{Evaluation}
\label{sec:core-language:eval}

\begin{figure}
   \input{fig/core-language/eval}\vspace{1mm}
   \input{fig/core-language/match}
   \input{fig/core-language/eval-aux}
   \caption{Operational semantics}
   \label{fig:core-language:semantics}
\end{figure}

\input{fig/core-language/syntax-trace}

The judgement $\explVal{T}{\rho, e \evalR v}$ states that term $e$ under environment $\rho$ evaluates to value $v$. The evaluation rules for Booleans, integers and lists are standard and have unsurprising trace forms. The variable case is also standard, but we give an explicit inductive definition of the environment lookup relation $\envLookupS$ towards the bottom of \figref{core-language:syntax-trace}, again so that later we can perform analysis over proofs that an environment contains a binding. The evaluation of records and record projection are straightforward too; the trace form for a record contains a subtrace $T_i$ for each field, and the trace form $\trRecProj{T}{\vec{x}}{x_i}$ for record projection records both the fields $\vec{x}$ of the record and the field name $x_i$ that was selected. (Just storing the index $i$ would be sufficient, but $x_i$ is clearer.)

The rule for recursive let-bindings $\exLetRecMutual{h}{e}$ makes use of the auxiliary relation $\rho, h \closeDefsR \rho'$ in \figref{core-language:semantics}. This produces a new environment $\rho'$ by taking each function definition $\bind{x}{\sigma}$ in $h$ and mapping $x$ to a corresponding closure capturing the ambient environment $\rho$. It then evaluates $e$ under new environment $\rho'$, leaving as an overall trace $\trLetRecMutual{h}{T}$. \todo{Application case for primitives.} The final rule for application, $\exApp{e}{e'}$, evaluates $e$ to a closure $\exClosure{\rho_1}{h}{\sigma}$ and $e'$ to a value $v$. It then pattern matches $v$ against the function $\sigma$ to return the correct branch $e''$; this leaves a trace $w$ recording which pattern was matched, where the semantics for this relation $\matchR$ is defined later in $\secref{core-language:pattern-match}$. Lastly, it evaluates the function body $e''$ under the concatenation of the intermediate environments produced.

\subsubsection{Pattern matching}
\label{sec:core-language:pattern-match}

The judgement $\explVal{w}{v, \sigma \matchR \rho, \kappa}$ defined in \figref{core-language:semantics} states that eliminator $\sigma$ can match $v$ and produce environment $\rho$ and continuation $\kappa$, with $\rho$ containing the variable bindings that arose during the match. \emph{Matches} $w$ are a compact notation for proof terms for the $\matchR$ relation, analogous to traces.

Variable eliminators $\elimVar{x}{\kappa}$ matches any value, returning the singleton environment $\bind{x}{v}$ and continuation $\kappa$. Boolean eliminator match any Boolean value, returning the appropriate branch and the empty environment $\seqEmpty$. List eliminators $\elimList{\kappa}{\sigma}$ match any list; the nil case is analogous to the handling of Booleans, and the cons case depends on the fact that the nested eliminator $\sigma$ for the cons branch has the curried type $\tyFun{A}{\tyFun{\tyList{A}}{B}}$. First, we recursively match the head $v$ of type $A$ using $\sigma$, obtaining bindings $\rho$ and eliminator $\tau: \tyFun{\tyList{A}}{B}$ as the continuation. Then the tail $v'$ is matched using $\tau$ to yield additional bindings $\rho'$ and final continuation $\kappa'$. Record matching is similar: the empty record case resembles the nil case, and the non-empty case relies on the nested eliminator having curried type $\tyFun{\tyRec{\vec{\bind{x}{A}}}}{\tyFun{A'}{B}}$. The initial part $\vec{\bind{x}{v}}$ of the record is matched using $\sigma$, returning another eliminator $\sigma'$ of type $\tyFun{A'}{B}$. Then the last field $\bind{y}{u}$ is matched using $\sigma'$ to yield final continuation $\kappa$.
