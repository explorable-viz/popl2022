\newpage

\section{A core language for fine-grained data dependencies}
\label{sec:core-language}

To show how we achieve a system of fine-grained dependency tracking between structured outputs and inputs, we first introduce the core calculus for our language and then describe how we can enrich this to language so that it can support the notion of selection within a program -- this gives rise to the idea of data-linking. Afterwards, this will provide us the foundation to describe a richer surface language in Section \ref{sec:surface-language}.

\subsection{Syntax and typing}

\subsubsection{Typing}
We begin by introducing the types of our language in Figure \ref{fig:core-syntax-type} -- this consists of primitive types such as booleans $\tyBool$, integers $\tyInt$, and functions $\tyFun{A}{B}$, but additionally lists $\tyList{A}$, vectors $\tyVec{A}$, and records $\tyRec{\vec{\bind{x}{A}}}$ as data structures in order to better demonstrate more interesting relationships which can occur between the program structure and output. The notation $\seq{\bind{x}{A}}$  represents a sequence of bindings from variables $x$ to types $A$.
\input{fig/core-language/syntax-type}


\subsubsection{Syntax - Terms}
Next we describe the terms of our language as seen in Figure \ref{fig:core-syntax-term}.  These include as basic terms: booleans $\exTrue$ and $\exFalse$, integers $n$, variables $x$, and application $\exApp{e}{e'}$. We also provide as data structures: empty $\exNil$ and non-empty lists $\exCons{e}{e'}$, vectors $\exVec{e}{x}{e'}$ which are constructed in a list-comprehension style, and records $\exRec{\vec{\bind{x}{v}}}$ as a sequence of bindings between field names and values. These data structures are then accompanied with a variety of operations. 

The final two terms, namely anonymous functions, $\exLambda{\sigma}$, and recursive let-bindings, $\exLetRecMutual{h}{e}$, are less conventional as they involve $\sigma$-constructs where $\sigma$ is the single elimination form in our core language called an ``eliminator''. Eliminators are described in Section \ref{sssec:syntax-eliminator}, and we then revisit these two terms in more detail in \ref{sssec:syntax-eliminator-terms}. 
\input{fig/core-language/syntax-term}

\noindent
Most of the typing rules for terms are relatively straightforward and are given in Figure \ref{fig:core-typing-term} -- the only non-standard typing rules are those for anonymous functions $\exLambda{\sigma}$ and recursive let-bindings $\exLetRecMutual{h}{e}$. We again ask the reader to defer to Section \ref{sssec:syntax-eliminator} and \ref{sssec:syntax-eliminator-terms}. It should be noted that our implementation does not implement typing rules, but we give them for the sake of clarity.

\input{fig/core-language/typing-term}

\subsubsection{Syntax - Eliminators}
\label{sssec:syntax-eliminator}
We now introduce the concept of eliminators $\sigma$ -- these express pattern matching against terms $e$ to result in program continuations $\kappa$ which can be either terms or further eliminators. Rather than one elimination-form per type, we provide a single pattern-matching elimination form called an eliminator. Eliminators resemble the idea of case-trees commonly used when compiling languages with pattern-matching into intermediate forms. Formally, eliminators correspond to Hinze's notion of generalized tries \cite{hinze00} extended with variable bindings. 

A common alternative to this is to use case-expressions, however, real-world functional languages have rich pattern-matching features such as piecewise definitions, view patterns, pattern synonyms, etc with non-trivial exhaustiveness-checking rules. Instead, we want an efficient, simple core pattern-matching feature that is total by construction and can serve as an elaboration target for more advanced features -- in section \ref{sec:surface-language} we show how to desugar piecewise definitions that satisfy certain well-formedness conditions into eliminators. 

Our language provides eliminators for matching against variables, booleans, records, and lists -- we explain the syntax of each eliminator (Figure \ref{fig:core-syntax-eliminator}) and give insight on how they work in reference to their typing rules (Figure \ref{fig:core-typing-eliminator}). 
\input{fig/core-language/syntax-eliminator}

\input{fig/core-language/typing-eliminator}

\noindent
The variable-eliminator $\elimVar{x}{\kappa}$ matches against any value of type $A$, binds it to $x$, and then returns the continuation $\kappa$ of type $B$. The eliminator $\elimVar{x}{\kappa}$ is hence a function of type $\tyFun{A}{B}$.

The boolean-eliminator $\elimBool{\kappa}{\kappa'}$, where $\kappa$ and $\kappa'$ have the same type $A$, maps the boolean value $\exTrue$ to the continuation $\kappa$ and $\exFalse$ to the continuation $\kappa'$. The eliminator $\elimBool{\kappa}{\kappa'}$ is hence a function of type $\tyFun{\tyBool}{A}$. 

A record-eliminator $\elimRec{\seq{x}}{\kappa}$ matches a record with fields $\seq{x}$ and then continues as $\kappa$, where $\kappa$ is typed in a context with a binding for each variable in $\seq{x}$. If $\seq{x}$ is empty with the form $\kw{()}$, then $\kappa$ is typed with no additional bindings. If $\seq{x}$ is non-empty with the form $\vec{x} \concat y$, then the continuation $\kappa$ is necessarily another eliminator $\sigma$ with a curried type which matches a record of type $\tyRec{\vec{\bind{x}{A}}}$ and maps it to an eliminator of type $\tyFun{A'}{B}$. The rule for non-empty records allows us to equivalently treat an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}}}}{\tyFun{A'}{B}}$ as an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}} \concat \bind{y}{A'}}}{B}$ which matches against the same record but extended with another field $y$ of type $A'$. This can be viewed as the isomorphism between a function of type $\tyFun{\tyFun{A}{B}}{C}$ and a function of type $\tyFun{\tyProd{A}{B}}{C}$, but specialized to record types \cite{hinze00}. 

The final eliminator, the list-eliminator $\elimList{\kappa}{\sigma}$, combines some of the flavours of record and boolean eliminators. The first branch maps the empty list $\exNil$ to a continuation $\kappa$ of type $B$. The second branch maps the non-empty list constructor $(\symCons)$ to a curried eliminator $\sigma$ -- this eliminator then matches the head element of type $A$ and the rest of the list of type $\tyList{A}$, to return a type $B$.

As a last note, we give the typing rule for mutually recursive functions under judgement $\Gamma \vdash h: \Delta$, where $h = \vec{\bind{x}{\sigma}}$ is a sequence of function names bound to eliminators and $\Delta$ is a vector of variables bound to function types. This states that if all functions $\sigma_i$ are well-typed under the typing context $\Gamma \concat \Delta$, then the environment of mutually recursive functions $h$ is well-typed as $\Delta$ under context $\Gamma$.

\subsubsection{Syntax - Terms with eliminators}
\label{sssec:syntax-eliminator-terms}
Now that we have introduced eliminators, we can revisit our core-language's terms which involve eliminators in Figure \ref{fig:core-syntax-term} and their typing rules in Figure \ref{fig:core-typing-term}. Anonymous functions, $\exLambda{\sigma}$, allow us to inject eliminators $\sigma$ into terms by wrapping them in a constructor $\lambda$. This has no impact on the typing rules, hence $\sigma$ and $\exLambda{\sigma}$ have the same types. Recursive let-bindings are then denoted by $\exLetRecMutual{h}{e}$. Given that $h$ is a sequence of mutually recursive functions $\vec{\bind{x}{\sigma}}$ of type $\Delta$ (a vector of variables bound to function types) under context $\Gamma$, and $e$ has type $A$ in the context $\Gamma \concat \Delta$, then the entire term $\exLetRecMutual{h}{e}$ has type $A$ under context $\Gamma$. 

\subsubsection{Syntax - values}
Before we move on to considering how to represent data selections, we describe the final part of the core syntax - values. Firstly, the environment $\rho$ of a program consists of bindings between variables and values. The values $v$ which terms can then evaluate to include: booleans $\exTrue$ and $\exFalse$, integers $n$, empty $\exNil$ and non-empty lists $\exCons{u}{v}$, records $\exRec{\vec{\bind{x}{v}}}$, and vectors $\exVecVal{\vec{v}}{j}$ of values $\vec{v}$ with fixed-length $j$. Additionally, we have partially applied primitives $\exPrimOp{\phi}{\vec{v}}$ where $\phi$ is a primitive operation applied to an incomplete sequence of values $\vec{v}$, and function closures $\exClosure{\rho}{h}{\sigma}$ consisting of an environment $\rho$, a sequence of mutually recursive functions $h$, and eliminator $\sigma$. 
\input{fig/core-language/syntax-value}

\noindent
We follow this up with the typing rules for environments and values. For environments, the judgement $\vdash \rho: \Gamma$ states that if all the values $v_i$ of the environment are well typed, then the environment itself is well-typed. 

The typing rules for values $\vdash v: A$ are self-explanatory for integers, booleans, records, lists, and vectors, but we elaborate on partially-applied primitives and closures. Given a primitive operation $\phi$ which takes $i+j$ integer arguments to output an integer, when partially applied to a sequence of $i$ integers this produces a function which takes $j$ more integers. The typing rule for closures $\exClosure{\rho}{h}{\sigma}$ then states that given its local environment $\rho$ has type $\Gamma$, its environment of mutually recursive functions $h$ has type $\Delta$ under context $\Gamma$, and its eliminator $\sigma$ has type $\tyFun{A}{B}$ under context $\Delta \concat \Gamma$, then the entire closure has type $\Delta \concat \Gamma$.

\input{fig/core-language/typing-value}

\subsubsection{Annotated values and terms}

Now that the core calculus has been fully specified, this gives us a foundation to begin enriching our language to become suitable for tracking data dependencies. We introduce the notion of selection as the ability to select pieces of the program of interest, and then trace back from these values to the parts of the program that were involved in constructing them. This is achieved via annotating our language with ``selection states'' -- annotations allow us to think of the data type of terms and values as functors which associate selection information with these terms/values. 

\input{fig/core-language/syntax-selection}

\noindent
The syntax for annotations is given in Figure \ref{fig:core-syntax-selection}. The choice of annotation type is kept mostly abstract as there are various forms of selection information we may want to express in our language -- however, we rely on the assumption that annotations are required to be a lattice and therefore have forms for bottom $\bot$ and top $\top$. 

To incorporate annotations in our calculus, we first take all the first-order data forms and augment them with an annotation to indicate the selection state. As we are primarily interested in tracking data dependencies between values, we first give the annotation-augmented form of values -- this includes: booleans, $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{v}}}{\alpha}$, empty lists $\annNil{\alpha}$ and non-empty lists $\annCons{u}{v}{\alpha}$, and vectors $\annVecVal{\vec{v}}{\annInt{j}{\alpha}}{\smash{\alpha'}}$.

In order to then propagate the selection-state information of values back to the expressions of our our program which are responsible for creating them, we must also add annotations to the necessary expression forms of our language, $e$. These correspond to the annotated forms of values, and hence include: booleans, $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{e}}}{\alpha}$, empty lists $\annNil{\alpha}$ and non-empty lists $\annCons{e}{e'}{\alpha}$, and vectors $\annVec{e}{x}{e'}{\alpha}$.

% Annotations allow us to think of the data type of expressions and values as a functor which associates terms/values with selection information.
% We want to be generic in the choice of annotation type as there are various forms of selection information we may want to express on our language, but we do want to rely on some assumptions about it so that it's not a completely abstract type. Hence it always has to be of type lattice. 
% Hole is a special expression form that corresponds to annotating every position within the term with the bottom element of a lattice.
% In order for our calculus to track data dependencies, the approach we take is to treat values as a functor which allows us to associate selection information with individual sub-terms in the value.
% We need to explain a lattice.
% We can recover a language isomorphic to the conventional syntax without annotations by instantiating the data type of expressions with the trivial one-point lattice, ().
% The expression forms which involve the construction of values are all associated with annotations - this is how we represent selections/selective pieces of syntax, or, this is how we trace back from values of the output that the user has selected to the parts of the program that were involved in constructing these values.
% Holes $\hole$ can be used to substitute for terms which have been considered of no interest.

\subsection{Evaluation}

\input{fig/core-language/syntax-trace}

Traces $T$ closely mirror the terms of our language, and are a means of recording the details of program execution and providing an explanation of how a result was computed. These are computed during forward slicing, and allows slicing to then proceed backwards afterwards. Matches $w$ are specifically used to record which pattern was matched against in an eliminator and hence which branch was taken during program execution. 

\input{fig/core-language/match}
\input{fig/core-language/eval}
\input{fig/core-language/eval-aux}

\begin{definition}
   \label{def:core-language:closeDefs}
   Define the relation $\closeDefsR$ as given in \figref{core-language:eval-aux}.
\end{definition}

\subsection{Forward and backward Galois dependency}
\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

\begin{definition}[Order on selection state]
   Define $\leq$ to be the total order satisfying $\FF \leq \alpha$ and $\TT \leq \TT$.
\end{definition}

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

\input{fig/core-language/slicing/join-value}
\input{fig/core-language/slicing/join-elim}

\subsubsection{Pattern-matching}

\input{fig/core-language/slicing/match-fwd}
\input{fig/core-language/slicing/match-bwd}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}

\subsubsection{Evaluation}

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\input{fig/core-language/slicing/eval-fwd}
\input{fig/core-language/slicing/eval-bwd}
\input{fig/core-language/slicing/eval-aux}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}
