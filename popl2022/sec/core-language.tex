\newpage

\section{A core language for fine-grained data dependencies}
\label{sec:core-language}

To show how we achieve a system of fine-grained dependency tracking between structured outputs and inputs, we first introduce the core calculus for our language and describe how this gives rise to the fundamental ideas behind program-slicing and data-linking. This later provides us the foundations to describe a richer surface language in Section \ref{sec:surface-language}.

\subsection{Syntax and typing}

\subsubsection{Typing}
We begin by introducing the types of our language in Figure \ref{fig:core-syntax-type} -- this consists of primitive types such as booleans $\tyBool$, integers $\tyInt$, and functions $\tyFun{A}{B}$, but additionally lists $\tyList{A}$, vectors $\tyVec{A}$, and records $\tyRec{\vec{\bind{x}{A}}}$ as data structures in order to better demonstrate more interesting relationships which can occur between the program structure and output. The notation $\seq{\bind{x}{A}}$  represents a sequence of bindings from variables $x$ to types $A$.
\input{fig/core-language/syntax-type}


\subsubsection{Syntax - terms}
The terms of our language, $e$ given in Figure \ref{fig:core-syntax-term}, include as basic terms: booleans $\exTrue$ and $\exFalse$, integers $n$, empty $\exNil$ and non-empty lists $\exCons{e}{e'}$, and application $\exApp{e}{e'}$. An anonymous function is denoted by $\exLambda{\sigma}$ where $\sigma$ is the single elimination form in the core language, called an eliminator, and this is described in Section \ref{sssec:syntax-eliminator}. Recursive let-bindings, $\exLetRecMutual{h}{e}$, are defined through declaring a sequence of mutually recursive functions $h = \seq{\bind{x}{\sigma}}$ and body $e$. Finally, we also provide vectors $\exVec{e}{x}{e'}$ which are constructed in a list-comprehension style, records $\exRec{\vec{\bind{x}{v}}}$ as a sequence of bindings between field names and values, and various operations over these. 
\input{fig/core-language/syntax-term}

The typing rules for terms are relatively straightforward, but we give them in Figure 
\ref{fig:core-typing-term} for completeness. 
  
\input{fig/core-language/typing-term}

\subsubsection{Syntax - eliminators}
\label{sssec:syntax-eliminator}
Eliminators $\sigma$ express pattern matching against terms $e$ to result in program continuations $\kappa$ which can be either terms or further eliminators. Rather than one elimination-form per type, we provide a single pattern-matching elimination form called an eliminator \cite{hinze00}. A common alternative to this is to use case-expressions, however, real-world functional languages have rich pattern-matching features such as piecewise definitions, view patterns, pattern synonyms, etc with non-trivial exhaustiveness-checking rules. Instead, we want an efficient, simple core pattern-matching feature that is total by construction and can serve as an elaborate target for more advanced features -- in section \ref{sec:surface-language} we show how to desugar piecewise definitions that satisfy certain well-formedness conditions into eliminators. 

We provide eliminators for matching against variables, booleans, records, and lists. Matching a term $e$ against a variable-eliminator $\elimVar{x}{\kappa}$ results in binding $e$ as $x$ and then returning the continuation $\kappa$. Matching a term $e$ against a boolean-eliminator $\elimBool{\kappa}{\kappa'}$, this returns the continuation $\kappa$ if $e$ is true, or $\kappa'$ if $e$ is false. When matching a term $e$ against a record-eliminator $\elimRec{\seq{x}}{\kappa}$, this returns a continuation $\kappa$ if $e$ is a record where all of its fields can be bound to all variable names in $\seq{x}$. Finally, matching a term $e$ against a list-eliminator $\elimList{\kappa}{\sigma}$ returns a continuation $\kappa$ if $e$ is the empty list $\exNil$ or another eliminator $\sigma$ if $e$ is non-empty.

\input{fig/core-language/syntax-eliminator}

The typing rules in Figure \ref{fig:core-typing-eliminator} give further insight on how eliminators work. The judgement for eliminator typing rules, $\Gamma \vdash \sigma: \tyFun{A}{B}$, describes how the well-typedness of an eliminator decomposes into the types of its patterns and branches. 

For a variable-eliminator, given the pattern $x : A$ and branch $\kappa : B$, the eliminator $\elimVar{x}{\kappa}$ is hence a function of type $\tyFun{A}{B}$. For a boolean-eliminator, if the branches $\kappa$ and $\kappa'$ for patterns $\exTrue$ and $\exFalse$ are the same type $A$, then $\elimBool{\kappa}{\kappa'}$ is a function of type $\tyFun{\tyBool}{A}$. 

The types describing record-eliminators are slightly more involved. When matching against a non-empty record-eliminator $\elimRec{\vec{x} \concat y}{\sigma}$, this uses currying to pattern match: if matching against the pattern $\vec{x} \concat y : \tyRec{\vec{\bind{x}{A}} \concat \bind{y}{A'}}$ results in an eliminator of type $B$, then this can be curried such that matching against the pattern $\vec{x} : \tyRec{\vec{\bind{x}{A}}}$ results in an eliminator of type $\tyFun{A'}{B}$. When matching against an empty record-eliminator $\elimRecEmpty{\kappa}$, this simply returns a continuation $\kappa$. 

Typing rules for lists work similarly to records, where both branches must have the same output type $B$. Matching against the non-empty list constructor $(\symCons)$ results in an eliminator $\sigma$ which then has to match against the head of the list of type $A$ and the tail of the list of type $\tyList{A}$ to output the type $B$. Matching against an empty list simply returns a continuation of type $B$.

As a final note, the typing rule for mutually recursive functions under judgement $\Gamma \vdash h: \Delta$ states that if all functions $\sigma_i$ are well-typed under the typing context $\Gamma \concat \Delta$, then the environment of mutually recursive functions is well-typed under context $\Gamma$ with the type $\Delta$.

\input{fig/core-language/typing-eliminator}


\subsubsection{Syntax - values}
The environment $\rho$ of a program consists of bindings between variables and values. The values $v$ which terms can evaluate to include: holes $\hole$, integers $n$, records $\exRec{\vec{\bind{x}{v}}}$, empty $\exNil$ and non-empty lists $\exCons{u}{v}$ of values, and vectors $\exVecVal{\vec{v}}{j}$ of values $\vec{v}$ with fixed-length $j$. Additionally, we have partially applied primitives $\exPrimOp{\phi}{\vec{v}}$ where $\phi$ is a primitive operation applied to an incomplete sequence of values $\vec{v}$, and function closures $\exClosure{\rho}{h}{\sigma}$ consisting of an environment $\rho$, a sequence of mutually recursive functions $h$, and eliminator $\sigma$. 
\input{fig/core-language/syntax-value}

\input{fig/core-language/typing-value}

The typing rule for environments $\vdash \rho: \Gamma$ states that if all the values $v_i$ of the environment are well typed under the empty typing context, then the environment itself is well-typed. 

The typing rules for values $\vdash v: A$ are self-explanatory for integers, booleans, records, lists, and vectors. Given a primitive operation $\phi$ which takes $i+j$ integer arguments to output an integer, when partially applied to a sequence of $i$ integers this produces a function which takes $j$ more integers.

\subsubsection{Annotated values and terms}

\input{fig/core-language/syntax-selection}

% In order for our language to be able to track data dependencies,
% Holes $\hole$ can be used to substitute for terms which have been considered of no interest.



\subsection{Evaluation}
\input{fig/core-language/match}
\input{fig/core-language/eval}
\input{fig/core-language/eval-aux}

\begin{definition}
   \label{def:core-language:closeDefs}
   Define the relation $\closeDefsR$ as given in \figref{core-language:eval-aux}.
\end{definition}

\subsection{Forward and backward Galois dependency}
\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

\begin{definition}[Order on selection state]
   Define $\leq$ to be the total order satisfying $\FF \leq \alpha$ and $\TT \leq \TT$.
\end{definition}

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

\input{fig/core-language/slicing/join-value}
\input{fig/core-language/slicing/join-elim}

\subsubsection{Pattern-matching}

\input{fig/core-language/slicing/match-fwd}
\input{fig/core-language/slicing/match-bwd}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}

\subsubsection{Evaluation}

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\input{fig/core-language/slicing/eval-fwd}
\input{fig/core-language/slicing/eval-bwd}
\input{fig/core-language/slicing/eval-aux}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}
