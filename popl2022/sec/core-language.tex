\section{Core calculus}
\label{sec:core-language}

The core calculus, introduced in this section, is interesting for two reasons. First, it uses \emph{eliminators} to represent pattern matching, which is crucial for correctly analysing data dependencies. Second, our operational semantics collects traces that are used in \secref{data-dependencies} to define backward and forward analyses over program executions. To support focusing on sub-terms, \secref{data-dependencies} also extends the calculus with a notion of \emph{selection}. The core calculus will serve as the target for which the surface language in \secref{surface-language} desugars into.

\todo{Summarise what the section accomplishes. TP: I edited this to say what the two non-standard aspects of the calculus are to let the reader know in advance.}

\subsection{Syntax and typing}
\label{sec:core-language:syntax-typing}

Although our implementation in untyped, types help describe the structure of the core language. \figref{core-language:syntax} introduces the types $A, B$ including $\tyBool$, $\tyInt$ and function types $\tyFun{A}{B}$, but also lists $\tyList{A}$ and records $\tyRec{\vec{\bind{x}{A}}}$ which exemplify the two primary kinds of structured data we consider:\todo{TP: The following is obvious. Delete to save space (Note about matrices can be in implementation)} lists are representative of recursive datatypes with a varying structure, and records of data with a fixed shape. (Our implementation of the core language also supports matrices, which also have a fixed shape, so we omit these from the formalism.) As usual the notation $\bind{x}{A}$ denotes the binding of $x$ to $A$ (understood formally as a pair); $\seq{\bind{x}{A}}$ denotes the sequence of bindings that results from zipping same-length sequences $\vec{x}$ and $\vec{A}$. In a record type $\tyRec{\vec{\bind{x}{A}}}$ the field names in $\vec{x}$ are required to be unique.

\input{fig/core-language/syntax}

The terms of the language are defined in \figref{core-language:syntax}. These include Boolean constants $\exTrue$ and $\exFalse$, integers $n$, variables $x$, and applications $\exApp{e}{e'}$. Primitives are not first-class; the expression $\exAppPrim{\phi}{\vec{e}}$ is the fully saturated application of $\phi$ to a sequence of arguments. (First-class and infix primitives are provided by desugarings in \secref{surface-language}). We also provide list constructors $\exNil$ and $\exCons{e}{e'}$, record construction $\exRec{\vec{\bind{x}{e}}}$ and record projection $\exRecProj{e}{x}$. The final two term forms, anonymous functions $\exLambda{\sigma}$ and recursive let-bindings $\exLetRecMutual{h}{e}$ where $h$ is of the form $\vec{\bind{x}{\sigma}}$, are explained below. First we introduce the pattern-matching construct $\sigma$, which we call an \emph{eliminator}. The typing rules for terms are given in \figref{core-language:typing}, and are intended only to help a reader understand the language; the type system lacks features such as polymorphism which would be needed for an implementation. The main rules of interest are the ones which involve eliminators.

\subsection{Eliminators}
\label{sec:core-language:syntax-eliminator}

Eliminators $\sigma, \tau$ are also defined in \figref{core-language:syntax}, and are inspired by \citeauthor{connelly95}'s notion of generalised trie \cite{connelly95}, elaborated further by \citet{hinze00}. Eliminators specify how to match against a partial value of some type and select a continuation $\kappa$ for further execution, where $\kappa$ is either a term $e$ or another eliminator $\sigma$. The Boolean eliminator $\elimBool{\kappa}{\kappa'}$ selects either $\kappa$ or $\kappa'$ depending on whether the boolean value is $\exTrue$ or $\exFalse$. The record eliminator $\elimRec{\seq{x}}{\kappa}$ matches a record with fields $\seq{x}$ and then returns $\kappa$ with the variables $\seq{x}$ bound to the components of the record. The list eliminator $\elimList{\kappa}{\sigma}$ maps the empty list to $\kappa$ and a non-empty list to another eliminator $\sigma$ which specifies how the head and tail of the list are to be matched. The variable eliminator $\elimVar{x}{\kappa}$ extends the usual notion of trie, matching any value, binding it to $x$, and then returning $\kappa$. Eliminators resemble the ``case trees'' commonly used as an intermediate form when compiling languages with pattern-matching \cite{graf20}, and can serve as an elaboration target for more advanced features such as the piecewise definitions described in \secref{surface-language}. \todo{Motivate better}


\input{fig/core-language/typing}

The use of nested eliminators to represent demand on sub-values will become clearer if we consider the typing judgement $\Gamma \vdash \sigma: \tyFun{A}{B}$ for eliminators given in \figref{core-language:typing}. (Eliminators always have function type, so this should be read as a four-place relation, with $\to$ part of the notation.) The typing rule for variable eliminators reveals the connection between eliminators and functions: it converts a continuation $\kappa$ which can be assigned type $B$ under the assumption that $x$ is of type $A$ as an eliminator of type $\tyFun{A}{B}$. The typing rule for Boolean eliminators says that to make an eliminator of type $\tyFun{\tyBool}{A}$, we simply need two continuations $\kappa$ and $\kappa'$ of type $A$. The rule for the empty record states that to make an eliminator of type $\tyFun{\tyRec{}}{A}$, we simply need a continuation $\kappa$ of type $A$. The rule for non-empty records allows us to treat an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}}}}{\tyFun{A'}{B}}$ into an eliminator of type $\tyFun{\tyRec{\vec{\bind{x}{A}} \concat \bind{y}{A'}}}{B}$, representing the isomorphism between $\tyFun{\tyFun{A}{B}}{C}$ and $\tyFun{\tyProd{A}{B}}{C}$ but at the level of record types \cite{hinze00}. (Formalising eliminators precisely requires \citeauthor{bird98}-style nested datatypes \cite{bird98} and polymorphic recursion, but these details need not concern us here.)

The typing rule for list eliminators $\elimList{\kappa}{\sigma}$ combines some of the flavour of record and Boolean eliminators. To make an eliminator of type $\tyFun{\tyList{A}}{B}$, we need a continuation of type $B$ for the empty case, and an eliminator of type $\tyFun{A}{\tyFun{\tyList{A}}{B}}$ which can be treated as an eliminator of type $\tyFun{\tyProd{A}{\tyList{A}}}{B}$ in order to process the head and tail in the non-empty case.

\subsubsection{Eliminators as functions}

We can now revisit the term forms $\exLambda{\sigma}$ and $\exLetRecMutual{h}{e}$. If $\sigma$ is an eliminator of type $\tyFun{A}{B}$, then $\exLambda{\sigma}$ is an anonymous function of the same type. If $h$ is of the form $\vec{\bind{x}{\sigma}}$, then $\exLetRecMutual{h}{e}$ introduces a sequence of mutually recursive functions which are in scope in $e$. The typing rule for $\exLetRecMutual{h}{e}$ uses an auxiliary typing judgement $\Gamma \vdash h : \Delta$ which assigns to every $x$ in $\Delta$ a function type $\tyFun{A}{B}$ as long as the $\sigma$ to which $x$ is bound in $h$ has that type.

\subsubsection{Values}
Values $v, u$, and environments $\rho$ are also defined in \figref{core-language:syntax}, and are standard for call-by-value. To support mutual recursion, the closure form \todo{maybe we should say that our evaluation uses environments rather than substitution (as in normal CBV) because this is needed to understand dependencies when variables are involved? This also explains why we need closures, which I was initially confused about. Maybe we don't need to say this here, but we need to say it somewhere. I only realised this when I got to traces for variables.} $\exClosure{\rho}{h}{\sigma}$ captures the (possibly empty) sequence $h$ of functions with which the function was mutually defined, in addition to the ambient environment $\rho$. For the typing judgements $\vdash \rho: \Gamma$ and $\vdash v: A$ for environments and values (\figref{core-language:typing}), only the closure case is worth noting, which delegates to the typing rules for recursive definitions and eliminators.

\subsubsection{Evaluation}
\label{sec:core-language:eval}

\figref{core-language:semantics} gives the operational semantics of the core language. Following the ``proved transitions'' approach of \citeauthor{boudol89} for reversible CCS~\cite{boudol89}, we treat the operational semantics as an inductive data type whose inhabitants represent executions. This will allow us in \secref{data-dependencies} to define forward and backward analyses over a single execution. Because these proof terms can become quite cumbersome, we introduce a compact (term-like) syntax for them called \emph{traces} (\figref{core-language:syntax-trace}), similar to the approach taken by \citeauthor{perera16d} for $\pi$-calculus~\cite{perera16d}, that leave most of the indices implicit.
\todo{What does a trace \emph{represent}? We should say this to guide intuition. I would also expect a trace to be some kind of list of things. Here it is a tree structure. Maybe we can say, ``a trace is a tree structure which mirrors the derivation tree of the evaluation and provides a full record of how exactly the result was obtained''}

\begin{figure}
   \input{fig/core-language/eval}\vspace{1mm}
   \input{fig/core-language/match}
   \input{fig/core-language/eval-aux}
   \caption{Operational semantics}
   \label{fig:core-language:semantics}
\end{figure}

\input{fig/core-language/syntax-trace}

\subsubsection{Evaluation}
\label{sec:core-language:eval}

The judgement $\explVal{T}{\rho, e \evalR v}$ defined at the top of \figref{core-language:semantics} states that term $e$ under environment $\rho$ evaluates to value $v$. The evaluation rules for Booleans, integers and lists are standard and have unsurprising trace forms. For variables, we give an explicit inductive definition of the environment lookup relation $\envLookupR$ underneath the $\evalR$ relation, again so that later we can perform analysis over a proof that an environment contains a binding. The lambda rule is standard except that we specify $\seqEmpty$ for the sequence of definitions being simultaneously defined, since a lambda is not recursive. For record construction, the trace form contains a subtrace $T_i$ for each field, and for record projection, which also uses the lookup relation $\envLookupR$, the trace form $\trRecProj{T}{\vec{\bind{x}{v}}}{y}$ for record projection records both the record $\vec{\bind{x}{v}}$ and the field name $y$ that was selected.

\todo{Mutually recursive functions are clearly the most involved case. Could we perhaps just have a single recursive function to keep this simpler? (and leave mutually recursive functions to appendix in case we need them)}
The rule for (mutually) recursive functions $\exLetRecMutual{h}{e}$, where $h$ is a sequence $\vec{\bind{x}{\sigma}}$ of function definitions, makes use of the auxiliary relation $\rho, h \closeDefsR \rho'$ at the bottom of \figref{core-language:semantics}. This produces an environment $\rho'$ binding each name $x_i$ in $\vec{x}$ to the corresponding closure $\exClosure{\rho}{h}{\sigma_i}$ capturing both ambient environment $\rho$, and recursive definitions $h$ which will be needed for any recursive calls. For primitive applications, the trace records the values of the arguments which were passed to the operation $\phi$. The rule for application $\exApp{e}{e'}$ is slightly non-standard, because it must deal with both mutual recursion and pattern-matching. First we unpack the recursive definitions $h$ from the closure $\exClosure{\rho_1}{h}{\sigma}$ computed by $e$, and again use the auxiliary relation $\closeDefsR$ to promote this into an environment $\rho_2$ of closures. We then use the relation $\matchR$ explained below to match $v$ against the eliminator $\sigma$, obtaining the branch $e^\twoPrime$ of the function to be executed and parameter bindings $\rho_3$. In addition to subtraces $T$ and $U$ for the function and argument, the application trace $\trApp{T}{U}{w}{T'}$ also has subtraces $w$ for the pattern-match and $T'$ for the selected branch.

\subsubsection{Pattern matching}
\label{sec:core-language:pattern-match}

The judgement $\explVal{w}{v, \sigma \matchR \rho, \kappa}$ also defined in \figref{core-language:semantics} states that eliminator $\sigma$ can match $v$ and produce environment $\rho$ and continuation $\kappa$, with $\rho$ containing the variable bindings that arose during the match. \emph{Matches} $w$ are a compact notation for proof terms for the $\matchR$ relation, analogous to traces for the $\evalR$ relation.

Variable eliminators $\elimVar{x}{\kappa}$ matches any value, returning the singleton environment $\bind{x}{v}$ and continuation $\kappa$. Boolean eliminators match any Boolean value, returning the appropriate branch and empty environment $\seqEmpty$. List eliminators $\elimList{\kappa}{\sigma}$ match any list. The nil case is analogous to the handling of Booleans; the cons case depends on the fact that the nested eliminator $\sigma$ for the cons branch has the curried type $\tyFun{A}{\tyFun{\tyList{A}}{B}}$. First, we recursively match the head $v$ of type $A$ using $\sigma$, obtaining bindings $\rho$ and eliminator $\tau: \tyFun{\tyList{A}}{B}$ as the continuation. Then the tail $v'$ is matched using $\tau$ to yield additional bindings $\rho'$ and final continuation $\kappa'$. Record matching is similar: the empty record case resembles the nil case, and the non-empty case relies on the nested eliminator having curried type $\tyFun{\tyRec{\vec{\bind{x}{A}}}}{\tyFun{A'}{B}}$. The initial part $\vec{\bind{x}{v}}$ of the record is matched using $\sigma$, returning another eliminator $\sigma'$ of type $\tyFun{A'}{B}$. Then the last field $\bind{y}{u}$ is matched using $\sigma'$ to yield final continuation $\kappa$.
