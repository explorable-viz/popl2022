\subsection{Selections of a value}

The plain (unannotated) syntax described in \secref{core-language} can be recovered from annotated terms via the erasure operation $\erase{v}: \ValF{\Ann{A}} \to \ValF{\Unit}$ which forgets the annotations, where $\Unit$ is the trivial one-point lattice. We refer to $|v|$ as the \emph{shape} of the annotated value $v$, which is useful because we will be mostly concerned with the annotated values of a given shape. Allowing $\raw{u}, \raw{v}$ from now on to range over unannotated values, and reserving $u, v$ for annotated values (and similarly for terms and eliminators), we have:

\begin{definition}[Selections of $\raw{v}$]
   Define $\Sel{v}{A}$ to be the set of all values $v \in \ValF{\textcal{A}}$ that are of shape $\raw{v}$, i.e.
   ~that erase to $\raw{v}$.
\end{definition}

Since its elements have a fixed shape, $\SelF{v}$ is a ``representable'' functor: it is isomorphic to a function space whose domain is the set of annotation positions in $\raw{v}$. In particular, the pointwise comparison of any $v, v'$ in $\Sel{v}{A}$ using the partial order $\leq$ of $\Ann{A}$ is well-defined, as is the pointwise application (zip) of any binary operation~\cite{gibbons17}. It is easy to see that if $\Ann{A}$ is a lattice, then $\Sel{v}{A}$ is also a lattice $\Lattice{\top_{\raw{v}}}{\bot_{\raw{v}}}{\meet_{\raw{v}}}{\join_{\raw{v}}}$, with the lattice operations defined pointwise. For example, if $u$ and $u'$ have the same shape and $v$ and $v'$ have the same shape, the join of the two lists $(\annCons{u}{v}{\alpha})$ and $(\annCons{u'}{v'}{\alpha'})$ is equal to $\annCons{(u \join u')}{(v \join v')}{\alpha \join \alpha'}$. Similarly, the top element of $\Sel{v}{A}$ is the selection of $\raw{v}$ which has $\top$ at every annotation position. (We omit the $\raw{v}$ indices from the lattice operations if the intention is clear from the context.)

\subsubsection{Environment selections and hole equivalence}

The notion of the ``selections'' of $\raw{v}$ also extends pointwise to environments, so that $\Sel{\rho}{A}$ means the set of annotated environments $\rho'$ of shape $\raw{\rho}$, where an annotated environment is a sequence of bindings of variables to annotated values. This leads to one more detail that must be attended to before we turn to the dependency analysis in \secref{data-dependencies:analyses}. Analysing the demand that outputs place on inputs requires pushing selection information into environments, and then combining information from different branches using $\join$. Since environments contain other environments recursively, through closures, treated naively this is a very expensive operation. We thus need an efficient representation of environments where the majority of bindings are unselected.

We therefore enrich the set of annotated values $\ValF{\Ann{A}}$ with a distinguished element \emph{hole}, written $\hole$, which is an alternative notation for $\bot_{\raw{v}}$ for any $\raw{v}$, i.e.~the annotated value of shape $\raw{v}$ which has $\bot$ at every annotation position. The equivalence of $\hole$ to any such bottom element is established explicitly by the partial order defined in \figref{data-dependencies:leq}, by the rule which always allows $\hole$ on the left-hand side of $\leq$, and the rules which only allow $\hole$ on the right-hand side of $\leq$ if all the annotations that appear on the left-hand side are $\bot$. If we write $\eq$ for the \emph{hole equivalence} relation induced by $\leq$ on annotated terms, it should be clear that $\hole \join v \eq v$ and $\hole \meet v \eq \hole$. In turn this means environments can be combined using $\join$ efficiently, whenever one of the bindings being merged is $\hole$, simplify by discarding $\hole$ and returning the other binding without further processing.

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

Because $\hole$ is equivalent to $\bot_{\raw{v}}$ for any $\raw{v}$, all such bottom elements are hole-equivalent. For example, the annotated value $\annCons{\hole}{\hole}{\top}$ is hole-equivalent to $\annCons{5_{\bot}}{\hole}{\top}$, but also to $\annCons{6_{\bot}}{{\exNil_{\bot}}}{\top}$, and so the last two terms are hole-equivalent by transitivity.

%We can enrich this partial order by introducing hole $\hole$ into the set of annotated values $\Sel{v}{A}$, where holes let us represent any value in a fully unselected state (every annotation position within it is $\bot$).

% We can then introduce the notion of hole-equivalence, which captures the idea that we can refine a hole using a provided value structure $\raw{v}$ to produce an equivalent value $v$ where all annotation positions are $\bot$:

% when joining or meeting or zipping, the structures of two values have to be equal, but we can relax the notion of equivalence to think of holes to be structurally equal to any value.

% include examples of hole equivalence, e.g. the following are all equivalent up to `dot equals', for example hole is equivalent to cons of a hole with false and a hole, which is equivalent to cons of True with false on it and hole. Refining a hole with substructure produces an equivalent value as long as any annotation positions in the substructure are false.

% Given that lattices have the property of being partially ordered, annotations also induce a partial order on the annotated syntactic forms, where two values $v$ and $v'$ are related by $v \leq v$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$. This relation is defined for values and eliminators in \figref{leq-value-eliminator} and terms in \figref{leq-term}, and is later necessary for lifting the lattice properties of selection types $\mathcal{A}$ to the type of syntax annotated with $\mathcal{A}$.

% Every partial order has an equivalence relation that it induces and that relation which we write as 'dot equals' is going to make \hole equivalent to any value that only has false annotations. Whenever hole occurs in a value position, we always know what shape the value is expected to have (because we always run the analysis in the context of a known shape). This means we can use the equivalent non-hole form to know what to do in that situation.

% In the figure for forward and backward dependency, we always have the first rule which uses hole equivalence. For fwd, it says that if \rho, e are hole-equivalent to \rho', e', then the forward analyses are equivalent. For bwd, if v is hole equivalent to u, then the backward analysis for v is the same as the backward analysis for u. If we have some kind of value that is either a hole or has some holes within it, and it is insufficiently specified for any of the other equations for hole, then we know that we can specialize it into a structure that has the other equation plus hole by explicitly fleshing it out.
