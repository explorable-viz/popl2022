\subsection{Selections of a value}

We can recover the syntax of unannotated values described in \secref{core-language} from annotated values by defining an erasure operation $\erase{v} : \tyFun{\ValF{\textcal{A}}}{\ValF{\Unit}}$ which erases its annotations of type $\textcal{A}$ to be the trivial one-point lattice $\Unit$. We can hence think of $|v|$ as the underlying shape of the annotated value $v$. From now on, we will use $\mathbf{u}, \mathbf{v}$ to range over \textit{unannotated} values and reserve $u, v$ for \textit{annotated} values (and similarly for terms and eliminators). This is useful for letting us consider all annotated values of a given shape:

\begin{definition}[Selections of $\mathbf{v}$ for a selection type $\textcal{A}$]
   Define $\Sel{v}{A}$ as the set of all values $v$ annotated with selection type $\textcal{A}$ that are of the shape $\textbf{v}$, i.e. $v$ erases to $\mathbf{v}$.
\end{definition}

Since the elements of $\SelF{v}$ have a fixed shape, $\SelF{v}$ is a \textit{representable} functor with a fixed shape given by $\mathbf{v}$. In particular, for any $v, v'$ in $\Sel{v}{A}$, the zip of a binary operation over $v$ and $v'$ is well-defined \cite{gibbons17}. In turn, this means that if $\textcal{A}$ is a lattice then $\Sel{v}{A}$ is also a lattice with meet and join defined by zipping the meet and join of $\textcal{A}$ over $v$ and $v'$. For example, the join of two cons values $(\annCons{u}{v}{\alpha})$ and $(\annCons{u'}{v'}{\alpha'})$ involves recursively joining over $u$ and $u'$, and $v$ and $v'$, and then also taking the join of $\alpha$ and $\alpha'$ to result in $\annCons{(u \join u')}{(v \join v')}{\alpha \join \alpha'}$. The top element of $\Sel{v}{A}$ is then the value $v$ with shape $\mathbf{v}$ which has the top element of $\textcal{A}$ at every annotation position, and conversely for the bottom element.

\newpage
\subsubsection{Hole equivalence}

% By annotating values with lattices as selection types, we can also introduce the notion of \textit{holes} $\hole$ as special values that express annotating every position within a value with the bottom element of a lattice.

As lattices are partially ordered, annotations $\textcal{A}$ also induce a partial order on annotated values $\Sel{v}{A}$, where two values $v$ and $v'$ are related by $\leq$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$ (defined in \figref{leq-value-eliminator} and \figref{leq-term}). We can then enrich the set of annotated values $\Sel{v}{A}$ by introducing the distinguished element hole $\hole_{\mathbf{v}}$, which is alternative notation for the bottom element of $\Sel{v}{A}$, i.e. the value of shape $\mathbf{v}$ where all annotation positions are $\bot$. As a consequence, it follows that $\hole \join v = v$ and $v \join \hole = v$ for any $v$, and conversely that $\hole \meet v = \hole$ and $v \meet \hole = \hole$.

The $\leq$ relation with holes induces an equivalence relation, $\eq$, which we call \textit{hole equivalence}:

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

This equivalence relation means that value selections can have multiple representations, and captures the idea that any substructures of a value $v$ that are annotated completely with $\bot$ can equivalently be replaced by a hole. For example, the following values are hole equivalent: $(\annCons{\hole_{\kw{\textbf{true}}}}{\hole_{\kw{\textbf{[]}}}}{\top})$, $(\annCons{\exTrue_{\bot}}{\hole_{\kw{\textbf{[]}}}}{\top})$, $(\annCons{\hole_{\kw{\textbf{true}}}}{\exNil_{\bot}}{\top})$, and $(\annCons{\exTrue_{\bot}}{\hole_{\exNil_{\bot}}}{\top})$. The notion of holes is important for performance purposes, as we often need an efficient representation of environments where the majority of bindings are unselected.

%We can enrich this partial order by introducing hole $\hole$ into the set of annotated values $\Sel{v}{A}$, where holes let us represent any value in a fully unselected state (every annotation position within it is $\bot$).

% We can then introduce the notion of hole-equivalence, which captures the idea that we can refine a hole using a provided value structure $\mathbf{v}$ to produce an equivalent value $v$ where all annotation positions are $\bot$:

% when joining or meeting or zipping, the structures of two values have to be equal, but we can relax the notion of equivalence to think of holes to be structurally equal to any value.

% include examples of hole equivalence, e.g. the following are all equivalent up to `dot equals', for example hole is equivalent to cons of a hole with false and a hole, which is equivalent to cons of True with false on it and hole. Refining a hole with substructure produces an equivalent value as long as any annotation positions in the substructure are false.

% Given that lattices have the property of being partially ordered, annotations also induce a partial order on the annotated syntactic forms, where two values $v$ and $v'$ are related by $v \leq v$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$. This relation is defined for values and eliminators in \figref{leq-value-eliminator} and terms in \figref{leq-term}, and is later necessary for lifting the lattice properties of selection types $\mathcal{A}$ to the type of syntax annotated with $\mathcal{A}$.

% Every partial order has an equivalence relation that it induces and that relation which we write as 'dot equals' is going to make \hole equivalent to any value that only has false annotations. Whenever hole occurs in a value position, we always know what shape the value is expected to have (because we always run the analysis in the context of a known shape). This means we can use the equivalent non-hole form to know what to do in that situation.

% In the figure for forward and backward dependency, we always have the first rule which uses hole equivalence. For fwd, it says that if \rho, e are hole-equivalent to \rho', e', then the forward analyses are equivalent. For bwd, if v is hole equivalent to u, then the backward analysis for v is the same as the backward analysis for u. If we have some kind of value that is either a hole or has some holes within it, and it is insufficiently specified for any of the other equations for hole, then we know that we can specialize it into a structure that has the other equation plus hole by explicitly fleshing it out.
