\subsection{Selections of a value}

The plain (unannotated) syntax described in \secref{core-language} can be recovered from annotated terms via the erasure operation $\erase{v}: \ValF{\textcal{A}} \to \ValF{\Unit}$ which forgets the annotations, where $\Unit$ is the trivial one-point lattice. We refer to $|v|$ as the \emph{shape} of the annotated value $v$, which is useful because we will be mostly concerned with the annotated values of a given shape. From now on we will use $\raw{u}, \raw{v}$ to range over unannotated values, and reserve $u, v$ for annotated values (and similarly for terms and eliminators).

\begin{definition}[Selections of $\raw{v}$]
   Define $\Sel{v}{A}$ to be the set of all values $v \in \ValF{\textcal{A}}$ that are of shape $\raw{v}$, i.e.
   ~that erase to $\raw{v}$.
\end{definition}

Since its elements have a fixed shape, $\SelF{v}$ is a ``representable'' functor: it is isomorphic to a function space whose domain is the set of annotation positions in $\raw{v}$. In particular, for any $v, v'$ in $\Sel{v}{A}$, the zip of a binary operation over $v$ and $v'$ is well-defined \cite{gibbons17}. In turn, this means that if $\textcal{A}$ is a lattice then $\Sel{v}{A}$ is also a lattice with meet and join defined by zipping the meet and join of $\textcal{A}$ over $v$ and $v'$. For example, the join of two cons values $(\annCons{u}{v}{\alpha})$ and $(\annCons{u'}{v'}{\alpha'})$ involves recursively joining over $u$ and $u'$, and $v$ and $v'$, and then also taking the join of $\alpha$ and $\alpha'$ to result in $\annCons{(u \join u')}{(v \join v')}{\alpha \join \alpha'}$. The top element of $\Sel{v}{A}$ is then the value $v$ with shape $\raw{v}$ which has the top element of $\textcal{A}$ at every annotation position, and conversely for the bottom element.

\subsubsection{Hole equivalence}

% By annotating values with lattices as selection types, we can also introduce the notion of \textit{holes} $\hole$ as special values that express annotating every position within a value with the bottom element of a lattice.

As lattices are partially ordered, annotations $\textcal{A}$ also induce a partial order on annotated values $\Sel{v}{A}$, where two values $v$ and $v'$ are related by $\leq$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$ (defined in \figref{leq-valMaybe come-eliminator} and \figref{leq-term}). We can then enrich the set of annotated values $\Sel{v}{A}$ by introducing the distinguished element hole $\hole_{\raw{v}}$, which is alternative notation for the bottom element of $\Sel{v}{A}$, i.e. the value of shape $\raw{v}$ where all annotation positions are $\bot$. As a consequence, it follows that $\hole \join v = v = v \join \hole$ for any $v$, and conversely that $\hole \meet v = \hole = v \meet \hole$.

The $\leq$ relation with holes induces an equivalence relation, $\eq$, which we call \textit{hole equivalence}:

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

This equivalence relation means that value selections can have multiple representations, and captures the idea that any substructures of a value $v$ that are annotated completely with $\bot$ can equivalently be replaced by a hole. For example, the following values $(\annCons{\hole_{5}}{\hole_{\kw{[]}}}{\top})$, $(\annCons{5_{\bot}}{\hole_{\kw{[]}}}{\top})$, and $(\annCons{\hole_{5}}{\exNil_{\bot}}{\top})$ are all hole equivalent to $(\annCons{5_{\bot}}{{\exNil_{\bot}}}{\top})$ and represent a singleton list where the cons constructor has been selected and the head and tail are unselected. The notion of holes is important for performance purposes, as we often need an efficient representation of environments where the majority of bindings are unselected.

%We can enrich this partial order by introducing hole $\hole$ into the set of annotated values $\Sel{v}{A}$, where holes let us represent any value in a fully unselected state (every annotation position within it is $\bot$).

% We can then introduce the notion of hole-equivalence, which captures the idea that we can refine a hole using a provided value structure $\raw{v}$ to produce an equivalent value $v$ where all annotation positions are $\bot$:

% when joining or meeting or zipping, the structures of two values have to be equal, but we can relax the notion of equivalence to think of holes to be structurally equal to any value.

% include examples of hole equivalence, e.g. the following are all equivalent up to `dot equals', for example hole is equivalent to cons of a hole with false and a hole, which is equivalent to cons of True with false on it and hole. Refining a hole with substructure produces an equivalent value as long as any annotation positions in the substructure are false.

% Given that lattices have the property of being partially ordered, annotations also induce a partial order on the annotated syntactic forms, where two values $v$ and $v'$ are related by $v \leq v$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$. This relation is defined for values and eliminators in \figref{leq-value-eliminator} and terms in \figref{leq-term}, and is later necessary for lifting the lattice properties of selection types $\mathcal{A}$ to the type of syntax annotated with $\mathcal{A}$.

% Every partial order has an equivalence relation that it induces and that relation which we write as 'dot equals' is going to make \hole equivalent to any value that only has false annotations. Whenever hole occurs in a value position, we always know what shape the value is expected to have (because we always run the analysis in the context of a known shape). This means we can use the equivalent non-hole form to know what to do in that situation.

% In the figure for forward and backward dependency, we always have the first rule which uses hole equivalence. For fwd, it says that if \rho, e are hole-equivalent to \rho', e', then the forward analyses are equivalent. For bwd, if v is hole equivalent to u, then the backward analysis for v is the same as the backward analysis for u. If we have some kind of value that is either a hole or has some holes within it, and it is insufficiently specified for any of the other equations for hole, then we know that we can specialize it into a structure that has the other equation plus hole by explicitly fleshing it out.
