\subsection{Galois dependency}
\label{sec:data-dependencies:analyses}

We now show how to interpret a selection on a term $\raw{e}$ or its environment $\raw{\rho}$ (collectively: an \emph{input selection}) as a selection on its output $\raw{v}$, and vice versa. In the forward direction, input selections represent (non-linear) \emph{resources} available for use, giving rise to output selections indicating the resources available to a downstream computation that depend only on selected input. In the backward direction, output selections represent resources being demanded by a downstream computation, giving rise to input selections identifying the resources needed for the selected output. Both analyses are with respect to a fixed computation $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$, where $T$ is a trace. (Typically one would first evaluate a program to obtain its trace $T$, and then run a forward or background analysis over $T$ with an appropriate lattice.) We call our analysis \emph{Galois dependency}, because the two directions form a Galois connection, a pair of functions that are each other's closest approximate inverse: from above in one direction, from below in the other (\secref{data-dependencies:analysis:galois-connections}).  We present the forward direction first and explain the underlying principles.

\subsection{Forward data dependency}
\label{sec:data-dependencies:analyses:fwd}

The forward data dependency analysis ``replays'' evaluation, propagating selections from inputs to outputs, with $T$ guiding the analysis whenever holes in the selectable program would mean the analysis would otherwise get stuck. Pattern-matching introduces the idea of a selection as a set of resources available to a downstream computation, so we start with that.

\input{fig/core-language/slicing/eval-fwd}

\subsubsection{Forward matching}
\label{sec:data-dependencies:analyses:fwd:pattern-match}

\figref{data-dependencies:fwd} defines a family of \emph{forward-matching} functions $\matchFwdF{w}$ of type $\Sel{\raw{v}, \raw{\sigma}}{A} \to \Sel{\raw{\rho}, \raw{\kappa}}{A} \times \Ann{A}$ for any $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$. (The definition is presented in a relational style for readability, but should be understood as a total function defined by structural recursion on $w$.) Forward-match replays the match witnessed by $w$, transferring the selections on the relevant parts of $v \in \Sel{\raw{v}}{A}$ to the output environment $\rho \in \Sel{\raw{\rho}}{A}$, and from the relevant part of $\sigma \in \Sel{\raw{\sigma}}{A}$ to the chosen continuation $\kappa \in \Sel{\raw{\kappa}}{A}$.

$\matchFwdF{w}$ also returns the \emph{meet} of the selection states associated with the part of $v$ consumed by $\sigma$, which we call the \emph{availability} of $v$ (in the context of $\sigma$), since it represents the extent to which the demand implied by $\sigma$ was met. A variable match consumes nothing of $v$ and so the availability is always $\top$, the unit for meet. A Boolean match consumes either $\annot{\exTrue}{\alpha}$ or $\annot{\exFalse}{\alpha}$, with availability $\alpha$; empty list and record matches are similar. When we match a cons, we return the meet of the $\alpha$ on the cons node itself with the availabilities $\beta$ and $\beta'$ computed for $v$ and $v'$. Non-empty records are similar, but to process the initial part of the record, we supply the neutral selection state $\top$ on the subrecord in order to use the definition recursively. (Subrecords are not first-class, but exist only as intermediate artefacts of the interpreter.)

One might imagine dispensing with the need for $w$ by simply defining $\matchFwdF{w}$ by case analysis on $v$ and $\sigma$. However, it is then unclear how to proceed in the event that $v$ is a hole. It would be legitimate to produce $\hole$ as the output continuation and $\bot$ as the output selection state, but for the output environment to be well-typed, it must provide variable bindings corresponding to those introduced in the baseline computation where $\raw{v}$ was matched against $\raw{\sigma}$. If $\matchFwdS$ is defined with respect to a known $w$, this can be achieved via an additional rule \ruleName{$\matchFwdS$-hole-1} that defines the behaviour at hole to be the same as the behaviour at any $\eq$-equivalent value in $\Sel{\raw{v}}{A}$. The \ruleName{$\matchFwdS$-hole-2} makes a similar provision for $\sigma$, which may also be a hole. Operationally, these rules can be interpreted as ``expanding'' enough of the holes in $v$ or $\sigma$ to make another rule of the definition match. There will be exactly one non-hole rule that matches, corresponding to the execution path originally taken, and although there may be multiple such expansions, the following property implies that the result of $\matchFwdF{w}$ will be unique up to $\eq$.

\begin{lemma}[Monotonicity of $\matchFwdF{w}$]
   Suppose $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$, with $v, \sigma \matchFwdR{w} \rho, \kappa, \alpha$ and $v', \sigma' \matchFwdR{w} \rho', \kappa', \alpha'$. If $(v, \sigma) \leq (v', \sigma)$ then $(\rho, \kappa, \alpha) \leq (\rho', \kappa', \alpha')$.
\end{lemma}

\subsubsection{Forward evaluation}

\figref{data-dependencies:fwd} also defines a family of \emph{forward-evaluation} functions $\evalFwdF{T}$ of type $\Sel{\raw{\rho}, \raw{e}}{A} \times \Ann{A} \to \Sel{\raw{v}}{A}$ for any $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$. Like forward-match, forward-evaluation is presented in a relational style, but should be understood as a total function defined by structural recursion on $T$. Forward evaluation replays $T$, using the input selection $\rho, e \in \Sel{\raw{\rho}, \raw{e}}{A}$ to determine an output selection $v \in \Sel{\raw{v}}{A}$. The rules mirror those of the evaluation relation $\evalR$, although there is an additional selection state input $\alpha$ called the \emph{ambient availability}. We explain this with reference to the application rule, which is the only point where a new ambient availability is assigned.

\paragraph{Function application} The rule assumes the application $\exApp{e}{e'}$ already has an ambient availability $\alpha$; at the outermost level this will usually be $\top$. The rule passes $\alpha$ down when recursively forward-evaluating $e$ and $e'$, but computes a new selection state $\beta$ when transferring control to the function. The $\beta$ is obtained by forward-matching the argument $v$ with the eliminator $\sigma$ of the closure, and thus represents the availability of those parts of $v$ demanded by the function. The ambient availability is used to upper-bound the availability of any selectable values constructed in the dynamic context of that function, establishing a dependency between the resources consumed by functions and resources they produce. The definition of the auxiliary function $\closeDefsFwdF{\rho,h}$ of type $\Sel{\raw{\rho},\raw{h}}{A} \to \Sel{\raw{\rho}'}{A}$ for any $\smash{\raw{\rho}, \raw{h} \closeDefsR \raw{\rho'}}$ is omitted; it is simply the $\closeDefsR$ relation defined in \figref{core-language:semantics}, extended to selectable values and domain-restricted to selections of $\raw{\rho}, \raw{h}$.

\paragraph{Primitive application} Primitive operations are the other source of input-output dependencies beyond user-defined functions. Since a primitive operation is opaque, these dependencies cannot be derived from its execution, but must be specified by the primitive operation directly. More specifically, $\phi \in \tyInt^{i} \to \tyInt$ is required to provide a forward-dependency function $\primFwdBool{\phi}{\vec{n}}: \Ann{A}^i \toÂ \Ann{A}$ for every $\vec{n} \in \tyInt^i$ which specifies how to turn an input selection $\vec{\alpha} \in \Ann{A}^i$ for $\vec{n}$ into an output selection $\alpha'$ on $\exAppPrim{\phi}{\vec{n}}$. There is one such function per possible input $\vec{n}$, since the dynamic dependencies for a primitive operation with an annihilator, such as multiplication, depend on the values passed to the operation. Primitives are free to implement forward-dependency however they want; however, \secref{data-dependencies:analyses:bwd:eval} will also require $\phi$ to provide a backward-dependency function for any input $\vec{n}$, and the two must form an adjoint pair for the consistency of the whole system to be guaranteed.

\paragraph{Other rules} All other rules pass the ambient availability into any subcomputations unchanged. Variable lookup, lambda and letrec do not directly produce or consume any (selectable) resources, and so disregard the ambient $\alpha$ entirely, although they preserve any selections internal to the subvalues they manipulate. Record projection is more interesting, disregarding not only the ambient $\alpha$ but also the availability $\beta$ of the record itself. Containers are considered to be independent of the values they contain: here, $v_i$ has its own internal availability which is preserved by projection, but there is no implied dependency of the field on the record from which it was projected. Record construction also reflects this principle, preserving the field selections into the resulting record selection unchanged. But it also sets the availability of the record value to be the meet of $\alpha$ and $\alpha'$, reflecting the dependency of the container on the constructing expression and also on any resources consumed by the ambient function. The rules for nil, cons and integers are similar.

\paragraph{Hole case} The hole rule for $\evalFwdF{T}$ is similar to the rules for $\matchFwdF{w}$, except that no special treatment is needed for the holes that arise inside $\rho$, and environments themselves have no special $\hole$ form. Moreover, the elimination rules (application and record projection) must accommodate the case where the closure or record being eliminated is represented by $\hole$. In these rules $\evalFwdR{T}\eq$ denotes the relational composition of $\evalFwdR{T}$ and $\eq$. As with $\matchFwdF{w}$, these uses of $\eq$ can be understood operationally as using the information in $T$ to expand $\hole$ sufficiently for the rule to apply, with a result which is unique up to $\eq$, which is again implied by the following property.

\begin{lemma}[Monotonicity of $\evalFwdF{T}$]
   Suppose $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$ with $\rho, e, \alpha \evalFwdR{T} v$ and $\rho', e', \alpha' \evalFwdR{T} v'$. If $(\rho, e, \alpha) \leq (\rho', e', \alpha')$ then $v \leq v'$.
\end{lemma}

\subsection{Backward data dependency}
\label{sec:data-dependencies:analyses:bwd}

Backward analysis ``rewinds'' evaluation, turning output demand into input demand, with $T$ guiding the analysis backward.

\subsubsection{Backward matching}
\label{sec:data-dependencies:analyses:bwd:pattern-match}

\figref{data-dependencies:bwd} defines a family of \emph{backward-match} functions $\matchBwdF{w}$ of type $\Sel{\raw{\rho}, \raw{\kappa}}{A} \times \Ann{A} \to \Sel{\raw{v}, \raw{\sigma}}{A}$ for any $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$. Backward-match rewinds the match witnessed by $w$, turning demand on the environment and continuation into demand on the value and eliminator that were originally matched. The additional input $\alpha$ represents the downstream demand placed on any resources that were constructed in the context of this match; $\matchBwdF{w}$ transfers this to the matched portion of $\raw{v}$, establishing a backwards link between resources produced and resources consumed in a given function context.

In the variable case, no proper part of $\raw{v}$ was matched, so $\alpha$ is disregarded. The rule need only ensure that the demand $v$ in the singleton environment $\bind{x}{v}$ is propagated backward. If a Boolean constant was matched, $\alpha$ becomes the demand on that constant, and $\kappa$, capturing the demand on the continuation, is used to construct the demand on the original eliminator, with $\hole$ used to represent the absence of demand on the non-taken branch. (Using $\hole$ for this means matches $w$ need only retain information about taken branches.) The nil case is similar.

For a cons match $\matchCons{w}{w'}$, we split the environment into $\rho$ and $\rho'$ (there is a unique well-typed decomposition) and then backward-match $w$ and $w'$ recursively to obtain $v$ and $v'$, representing the demand on the head and tail of the list. These are combined into the demand on the entire list, using $\alpha$ as the demand on the cons node. $\sigma$ represents the demand on the interim eliminator used to match the tail, and $\tau$ the demand on the eliminator used to match the head, which are then combined into a demand on the eliminator used to match the whole list, with $\hole$ again used to represent the absence of demand on the nil branch. Records are similar, except there is only a single branch, and the selection state $\beta$ computed for the initial part of the record is an artefact of processing records recursively, and is disregarded.

\begin{lemma}[Monotonicity of $\matchBwdF{w}$]
   Suppose $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$, with $\rho, \kappa, \alpha \matchBwdR{w} v, \sigma$ and $\rho', \kappa', \alpha' \matchBwdR{w} v', \sigma'$. If $(\rho, \kappa, \alpha) \leq (\rho', \kappa', \alpha')$ then $(v, \sigma) \leq (v', \sigma)$.
\end{lemma}

\subsubsection{Backward evaluation}
\label{sec:data-dependencies:analyses:bwd:eval}

\figref{data-dependencies:bwd} also defines a family of \emph{backward-evaluation} functions $\evalBwdF{T}$ of type $\Sel{\raw{v}}{A} \to \Sel{\raw{\rho}, \raw{e}}{A} \times \Ann{A}$ for any $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$. Backward evaluation rewinds $T$, using the output selection $v \in \Sel{\raw{v}}{A}$ to determine an input selection $\rho, e \in \Sel{\raw{\rho}, \raw{e}}{A}$. The rules resemble those of the evaluation relation $\evalR$ with inputs and outputs flipped, and with an additional output $\alpha$ called the \emph{ambient demand}. The general pattern is that each backward rule takes the join of the demand attached to any partial values constructed at that step, and the ambient demand associated with any subcomputations, and passes it upwards as the new ambient demand. The output environment is constructed similarly, by joining the demand flowing back through the environment copies used to evaluate subcomputations. Demand is also attached to the source expression when it is the expression form responsible for the construction of a demanded value.

\paragraph{Function application} The application rule is where the ambient demand is used and the function context changes, so we start here. The rule essentially runs the forward evaluation rule in reverse, using the trace $T'$ to backward-evaluate the function body. The ambient demand $\beta$ associated with $T'$ is the join of the demand on any resources constructed directly by that function invocation, and is transferred to the matched part of the function argument by the backward-match function $\matchBwdF{w}$. The ambient demand passed upwards into the enclosing function context is $\alpha \join \alpha'$, representing the resources needed along $T$ and $U$. The family of auxiliary functions $\smash{\closeDefsBwdF{\rho, h}}$ of type $\smash{\Sel{\raw{\rho'}}{A} \to \Sel{\raw{\rho}, \raw{h}}{A}}$ for any $\raw{\rho}, \raw{h} \closeDefsR \raw{\rho'}$ defined at the bottom of \figref{data-dependencies:bwd} is used to turn $\rho_2$, capturing the demand flowing back through any recursive uses of the function and any others with which it was mutually defined, into information that can be merged back into the demand on the closure. The function $\closeDefsBwdF{\rho,h}$ is also used in the letrec rule, which otherwise follows the generic pattern describe above.

\input{fig/core-language/slicing/eval-bwd}

\paragraph{Primitive operations} Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must provide a backward-dependency  function $\primBwdBool{\phi}{\vec{n}}: \Ann{A} \to \Ann{A}^i$ for every $\vec{n} \in \tyInt^i$ which specifies how to turn the output selection $\alpha'$ on $\exAppPrim{\phi}{\vec{n}}$ into an input selection $\vec{a} \in \Ann{A}^i$ on $\vec{n}$. The rule for primitive application uses this information to pair each argument $n_i$ with its demand $\alpha_i$ and then backwards-evaluate the argument. The ambient demand passed upward is the join of those arising from these subcomputations, and is unrelated to the execution of the primitive itself, similar to a function application. Here $\bigjoin{\vec{\beta}}$ means the fold of $\join$ (with unit $\bot$) over the sequence of selection states $\seqRange{\beta_1}{\beta_{\length{\vec{x}}}'}$. The environment demands $\vec{\rho} = \seqRange{\rho_1}{\rho_{\length{\vec{n}}}}$ are joined (pointwise) in a similar fashion.

\paragraph{Other rules} In the variable case, no partial values were constructed during evaluation and there are no subcomputations, so the ambient demand is $\bot$, the unit for $\join$. The returned environment selection demands $v$ for the variable $x$ and $\hole$ for all other variables, using the family of \emph{backwards lookup} functions $\envLookupBwdF{-}{\rho}{x}{-}$ of type $\Sel{\raw{v}}{A} \to \Sel{\raw{\rho}}{A}$ for any $\envLookup{\raw{\rho}}{x}{\raw{v}}$ also defined in \figref{data-dependencies:bwd}. (The output of the function is on the left in the relational notation.) For atomic values such as integers and nil, the ambient demand is simply the demand $\alpha$ associated with the constructed value, which also attached to the corresponding expression, and the environment demand has $\hole$ for every variable in the original environment $\raw{\rho}$, written $\hole_{\raw{\rho}}$.

Closures are not directly selectable, so the ambient demand is $\bot$, and the rule simply unpacks the components, preserving any internal selections on $\rho$ and $\sigma$. Composite values such as records and cons cells follow the general pattern; thus for records, the ambient demands $\alpha'_i$ for the subcomputations are joined with the $\alpha$ on the record itself to produce the ambient demand passed upward. Record projection never demands the record constructor itself, but simply promotes the field demand into a record demand, using using $\envLookupBwdR{\vec{\bind{x}{\raw{v}}}}$ to demand any other fields with $\hole$.

\paragraph{Hole rule} The hole rule, as elsewhere, ensures that the function is defined when $v$ is $\hole$, and it is easy to show that $\evalBwdF{T}$  preserves $\leq$, and thus $\eq$.

\begin{lemma}[Monotonicity of $\evalBwdF{T}$]
   Suppose $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$ with $v \evalBwdR{T} \rho, e, \alpha $ and $v' \evalBwdR{T} \rho', e', \alpha' $. If $v \leq v'$ then $(\rho, e, \alpha) \leq (\rho', e', \alpha')$.
\end{lemma}

\subsection{Round-tripping properties of analyses}
\label{sec:data-dependencies:analysis:galois-connections}

The analyses above can be used to answer the kind of question we motivated in \secref{introduction:data-linking}, such as ``What data is needed to compute this bar in a bar chart?'' (We used our implementation to generate \figref{introduction:data-linking}.) If we are to rely on the answer, we need to know that the analyses satisfy certain correctness properties. Intuitively, we expect the backward analysis $\evalBwdF{T}$ to be ``sound'': to pick out all (and hopefully only) the input data needed for the output selection. Similarly, we expect the forward analysis $\evalFwdF{T}$ to be ``complete'': to pick out only (and hopefully all) output data that can be computed from the selected input. We can understand these requirements as \emph{round-tripping} properties: we expect $\evalFwdF{T}(\evalBwdF{T}(v))$ to produce a value selection $v' \geq v$, and $\evalBwdF{T}(\evalFwdF{T}(\rho,e))$ to produce an input selection $(\rho',e') \leq (\rho,e)$.

Pairs of (monotonic) functions $f: X \to Y$ and $g: Y \to X$ that satisfy these round-tripping properties are called \emph{Galois connections}. Galois connections generalise isomorphisms: $f$ and $g$ are not quite mutual inverses, but are the nearest to an inverse each can get to the other, a notion which is meaningful when the functions have domains that are partially ordered.

\begin{definition}[Galois connection]
   Suppose $X$ and $Y$ are sets equipped with partial orders $\numleq_X$ and $\numleq_Y$. Then monotonic functions $f: X \to Y$ and $g: Y \to X$ form a \emph{Galois connection}, written $g \adjoint f$, iff $f(g(y)) \numgeq_Y y$ and $g(f(x)) \numleq_X x$.
\end{definition}

\noindent The notation $g \adjoint f$ is justified by the fact that Galois connections are also a simple example of adjoint functors, where $X$ and $Y$ are poset categories. (In this context the right adjoint $f$ is called the \emph{upper adjoint} and the left adjoint $g$ is called the \emph{lower adjoint}.) Galois connections compose, so we show that $\evalBwdF{T}$ and $\evalFwdF{T}$ form a Galois connection (\thmref{core-language:eval:gc}) by first establishing that the relevant auxiliary functions also form Galois connections.

\begin{theorem}[Galois connection for pattern-matching]
   \label{thm:core-language:match:gc}
      Suppose $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$.  Then $\matchBwdF{w} \adjoint \matchFwdF{w}$.
\end{theorem}

\begin{proof}
\ifappendices See \appref{proofs:match:gc}. \else \ProofInSupplementaryMaterial \fi
\end{proof}

\begin{lemma}[Galois connection for environment lookup]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\raw{\rho}}{x}{\raw{v}}$. Then $(\envLookupBwdF{-}{\raw{\rho}}{x}{}) \adjoint (\envLookupFwdF{}{\raw{\rho}}{x}{-})$. \todo{Better notation for environment lookup functions.}
\end{lemma}

\begin{proof}
   \ifappendices See \appref{proofs:lookup:gc}. \else \ProofInSupplementaryMaterial \fi
   \end{proof}

   \begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\raw{\rho}, \raw{h} \closeDefsR \raw{\rho}'$.  Then ${\closeDefsBwdF{\raw{\rho},\raw{h}}} \adjoint {\closeDefsFwdF{\raw{\rho},\raw{h}}}$.
\end{theorem}

\begin{proof}
   \ifappendices See \appref{proofs:closeDefs:gc}. \else \ProofInSupplementaryMaterial \fi
   \end{proof}

We assume (rather than prove) that the forward and backwards dependency functions provided for a primitive operation $\phi: \tyInt^i \to \tyInt$ form a Galois connection between $\Ann{A}^i$ and $\Ann{A}$, i.e.~that $\primBwdBool{\phi}{\vec{n}} \adjoint \primFwdBool{\phi}{\vec{n}}$. Under this assumption the following holds.

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$.  Then $\evalBwdF{T} \adjoint \evalFwdF{T}$.
\end{theorem}

\begin{proof}
   \ifappendices See \appref{proofs:eval:gc}. \else \ProofInSupplementaryMaterial \fi
\end{proof}

Establishing that $\evalFwdF{T}$ and $\evalBwdF{T}$ form an adjoint pair might seem like a rather weak correctess property, since it offers no independent grounds for thinking that the definitions are useful, but merely ensures that they are related in an appropriate way. And it is certainly true that one could define $\evalFwdF{T}$ and $\evalBwdF{T}$ so that they are too coarse grained to be useful, just as correctness properties like soundness or completeness for other static or dynamic analyses do not by themselves guarantee utility. However, for a non-trivial definition, the Galois connection property is quite strong, and we leave for future work (\secref{conclusion}) identifying some independent basis for validating the definitions.
