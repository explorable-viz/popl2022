\subsection{Galois dependency}
\label{sec:data-dependencies:analyses}

We now show how to interpret a selection on a program $\raw{e}$ or its environment $\raw{\rho}$ (collectively: an \emph{input selection}) as a selection on its output $\raw{v}$, and vice versa. In the forward direction, input selections represent (non-linear) \emph{resources} available for use, giving rise to output selections indicating the resources available to a downstream computation because they depend only on selected input. In the backward direction, output selections represent resources being demanded by a downstream computation, giving rise to input selections identifying the resources needed for the selected output. Both analyses are with respect to a fixed computation $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$, where $T$ is a trace. (Typically one would first evaluate a program to obtain its trace $T$, and then run a forward or background analysis over $T$ with an appropriate lattice.) We call our analysis \emph{Galois dependency}, because the two directions form a Galois connection, a pair of functions that are each other's closest approximate inverse: from above in one direction, from below in the other (\secref{data-dependencies:analysis:galois-connections}).  We present the forward direction first and explain the underlying principles.

\subsection{Forward Galois dependency}
\label{sec:data-dependencies:analyses:fwd}

Forward analysis ``replays'' evaluation, propagating annotations from inputs to outputs, with $T$ guiding the analysis whenever when holes in the annotated program would mean the analysis would otherwise get stuck. Pattern-matching introduces the idea of a selection as a set of resources available to a downstream computation, so we start with that.

\input{fig/core-language/slicing/eval-fwd}

\subsubsection{Forward matching}
\label{sec:data-dependencies:analyses:fwd:pattern-match}

\figref{data-dependencies:fwd} defines the family of forward-analysis functions $\matchFwdF{w} :: \Sel{v, \sigma}{A} \to \Prod{\Sel{\rho, \kappa}{A}}{\Ann{A}}$ for any $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$, pronounced ``forward match''. (This is presented in a relational style for readability, but should be understood as a total function defined by structural recursion on $w$.) Forward-match replays the pattern-match witnessed by $w$, transferring the annotations on the relevant parts of $v \in \Sel{v}{A}$ to the output environment $\rho \in \Sel{\rho}{A}$, and from the relevant part of $\sigma \in \Sel{\sigma}{A}$ to the selected continuation $\kappa \in \Sel{\kappa}{A}$.

$\matchFwdF{w}$ also returns the \emph{meet} of the annotations on the part of $v$ consumed by $\sigma$, which we call the \emph{availability} of $v$ (in the context of $\sigma$), since it represents the extent to which the demand implied by $\sigma$ was met. A variable match consumes nothing of $v$ and so the availability is always $\top$, the unit for meet. A Boolean match consumes either $\annot{\exTrue}{\alpha}$ or $\annot{\exFalse}{\alpha}$, with availability $\alpha$; empty list and record matches are similar. When we match a cons, we combine the $\alpha$ on the cons node itself with the availabilities $\beta$ and $\beta'$ of $v$ and $v'$. Non-empty records are similar, but to process the rest of the record, we supply the neutral annotation $\top$ on the subrecord in order to use the definition recursively. (Subrecords are not first-class, but exist only as intermediate artefacts of the interpreter.)

One might hope to dispense with the need for $w$ by simply defining $\matchFwdF{w}$ by case analysis on $v$ and $\sigma$. However, it is not clear how to proceed in the event that $v$ or $\sigma$ is a hole. It would be legitimate to produce $\hole$ as the output continuation and $\bot$ as the output annotation, but for the output environment to be well-typed, it must have variable bindings corresponding to those introduced in the baseline computation where $\raw{v}$ was matched against $\raw{\sigma}$. If $\matchFwdS$ is defined with respect to a known $w$, this can be achieved via additional rules \ruleName{$\matchFwdS$-hole-1} and \ruleName{$\matchFwdS$-hole-2} that define the behaviour at hole to be the same as the behaviour at any $\eq$-equivalent argument. Operationally, this can be interpreted as ``expanding'' enough of the holes in $v$ or $\sigma$ to make another rule of the definition match; there will be exactly one non-hole rule that matches, corresponding to the execution path originally taken, and although there may be multiple such expansions, the result of $\matchFwdF{w}$ will be unique up to $\eq$.

\begin{lemma}[Determinism of $\matchFwdF{w}$]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\subsubsection{Forward evaluation}

\figref{data-dependencies:fwd} also defines the family of functions $\evalFwdF{T} :: \Prod{\Sel{\rho, e}{A}}{\Ann{A}} \to \Sel{v}{A}$ for any $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$, pronounced ``forward evaluation''. This too should be understood as a total function, defined by structural recursion on $T$. Forward evaluation replays $T$, using the input selection $\rho, e \in \Sel{\rho,e}{A}$ to determine the output selection $v \in \Sel{v}{A}$. Analogously to $\matchFwdF{w}$ and $\matchR$, the rules for $\evalFwdF{T}$ mirror those of the evaluation relation $\evalR$. We refer to the additional annotation input $\alpha$ as the \emph{ambient availability}. We explain this with reference to the application rule, which is the only point where the ambient availability may change.

The rule assumes the application $\exApp{e}{e'}$ already has an ambient availability $\alpha$; at the outermost level this will usually be $\top$. The rule retains $\alpha$ as the ambient availability when recursively forward-evaluating $e$ and $e'$, but computes a new annotation $\beta$ to use when transferring control to the function. We obtain $\beta$ by forward-matching the argument $v$ with the definition $\sigma$ of the closure, and thus it represents the availability of those parts of $v$ demanded by $\sigma$. The ambient availability is used to bound the availability of any annotated values constructed in that function context, establishing a dependency between the parts of values consumed by functions, and the parts of values they construct.

All other rules pass the ambient context into any subcomputations unchanged. The rules which do not construct annotated values disregard the function context entirely; the variable rule simply returns the annotated value bound to $x$ in $\rho$, and the rule for lambdas $\exLambda{\sigma}$ preserves any annotations in the environment $\rho$ and eliminator $\sigma$ into the resulting closure. The closure has no annotations of its own, so again the ambient availability $\alpha$ is disregarded. Record projection is more interesting, preserving any annotations internal to the projected field $v_i$ and disregarding not only the ambient $\alpha$ but also the annotation $\beta$ on the record itself. The additional principle here is that ``containers'' are, in general, independent of the values they contain; here, $v_i$ has its own internal annotations which are preserved by projection, but there is no implied dependency of the field on the record from which it was projected. Record construction also reflects this principle, by forward-evaluating the subcomputation for each field and transferring the resulting annotated value into the record unchanged. But it also annotates the record value with the meet of $\alpha$ and $\alpha'$, reflecting the idea that constructed values require both the constructing expression \emph{and} any resources needed by the ambient function. The rules for nil, cons and integers are similar, although lists have an annotation at every node, unlike records, which have a single annotation.

The hole rule for $\evalFwdF{T}$ is similar to the rules for $\matchFwdF{w}$, except that no special treatment is needed for the holes that arise inside $\rho$, and environments themselves have no special $\hole$ form. Moreover, the ``elimination rules'' (application, record projection and primitive application) must all accommodate the case where the annotated value being eliminated (closure, record, or primitive operation) is represented by $\hole$. In these rules $\evalFwdR{T}\eq$ denotes the relational composition of $\evalFwdR{T}$ and $\eq$. As with $\matchFwdF{w}$, these uses of $\eq$ can be understood operationally as using the information in $T$ to expand $\hole$ sufficiently for the rule to apply, with a result which is unique up to $\eq$.

\begin{lemma}[Determinism of $\evalFwdF{T}$]
   Suppose $\rho, e, \alpha \evalFwdR{T} v$ and $\rho', e', \alpha \evalFwdR{T} v'$. If $(\rho, e) \eq (\rho', e')$ then $v \eq v'$.
\end{lemma}

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\subsection{Backward Galois dependency}

Backward analysis ``rewinds'' evaluation, propagating annotations from outputs to inputs, with $T$ guiding the analysis backward.

\subsubsection{Pattern-matching}

The function $\matchBwdF{w} :: \Prod{\Sel{\rho, \kappa}{A}}{\Ann{A}} \to \Sel{v, \sigma}{A}$ can also be understood in two parts. First, we use the match $w$ to reconstruct the shape of the eliminator $\sigma$. The environment $\rho$ and continuation $\kappa$ resulting from the forward pattern-match are then used to determine the original continuation for the branch corresponding to $w$; all other branches are considered unused and hence have hole as their continuations. Second, we take the output selection $\alpha$ which tells us if all input resources were available when forward matching, and use this to annotate the original input value $v$.

The rule for variables $\matchVar{x}$, discards its output selection $\alpha$ as no selections were originally consumed when forward pattern-matching against a variable eliminator. For matches $w$ representing either $\matchTrue$ or $\matchFalse$, we take the output selection $\alpha$ and use this to annotate the Boolean value corresponding to $w$. The same logic applies to $\matchNil$. For non-empty lists, $\matchCons{w_1}{w_2}$, we backward match in reverse order against the tail pattern $w_2$ then the head pattern $w_1$ to acquire annotated values $v_2$ and $v_1$. Using this, we reconstruct the value $\annCons{v_1}{v_2}{\alpha}$ where the cons constructor is annotated by the output selection $\alpha$. Similarly for records, $\matchRec{\vec{\bind{x}{w}} \concat \bind{y}{w'}}$, we recursively backward match against all of the components of record and annotate the record constructor with the output selection $\alpha$.

\input{fig/core-language/slicing/eval-bwd}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\subsection{Galois connections}
\label{sec:data-dependencies:analysis:galois-connections}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}
