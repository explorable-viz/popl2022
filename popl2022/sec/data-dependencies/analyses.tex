\subsection{Galois dependency}
\label{sec:data-dependencies:analyses}

We now show how to interpret a selection on a program $\raw{e}$ or its environment $\raw{\rho}$ (collectively: an \emph{input selection}) as a selection on its output $\raw{v}$, and vice versa. In the forward direction, input selections represent (non-linear) \emph{resources} available for use, giving rise to output selections indicating the resources available to a downstream computation that depend only on selected input. In the backward direction, output selections represent resources being demanded by a downstream computation, giving rise to input selections identifying the resources needed for the selected output. Both analyses are with respect to a fixed computation $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$, where $T$ is a trace. (Typically one would first evaluate a program to obtain its trace $T$, and then run a forward or background analysis over $T$ with an appropriate lattice.) We call our analysis \emph{Galois dependency}, because the two directions form a Galois connection, a pair of functions that are each other's closest approximate inverse: from above in one direction, from below in the other (\secref{data-dependencies:analysis:galois-connections}).  We present the forward direction first and explain the underlying principles.

\subsection{Forward data dependency}
\label{sec:data-dependencies:analyses:fwd}

The forward data dependency analysis ``replays'' evaluation, propagating selections from inputs to outputs, with $T$ guiding the analysis whenever when holes in the selectable program would mean the analysis would otherwise get stuck. Pattern-matching introduces the idea of a selection as a set of resources available to a downstream computation, so we start with that.

\input{fig/core-language/slicing/eval-fwd}

\subsubsection{Forward matching}
\label{sec:data-dependencies:analyses:fwd:pattern-match}

\figref{data-dependencies:fwd} defines a family of \emph{forward-matching} functions $\matchFwdF{w}$ of type $\Sel{\raw{v}, \raw{\sigma}}{A} \to \Sel{\raw{\rho}, \raw{\kappa}}{A} \times \Ann{A}$ for any $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$. (The definition is presented in a relational style for readability, but should be understood as a total function defined by structural recursion on $w$.) Forward-match replays the match witnessed by $w$, transferring the selections on the relevant parts of $v \in \Sel{\raw{v}}{A}$ to the output environment $\rho \in \Sel{\raw{\rho}}{A}$, and from the relevant part of $\sigma \in \Sel{\raw{\sigma}}{A}$ to the chosen continuation $\kappa \in \Sel{\raw{\kappa}}{A}$.

$\matchFwdF{w}$ also returns the \emph{meet} of the selection states associated with the part of $v$ consumed by $\sigma$, which we call the \emph{availability} of $v$ (in the context of $\sigma$), since it represents the extent to which the demand implied by $\sigma$ was met. A variable match consumes nothing of $v$ and so the availability is always $\top$, the unit for meet. A Boolean match consumes either $\annot{\exTrue}{\alpha}$ or $\annot{\exFalse}{\alpha}$, with availability $\alpha$; empty list and record matches are similar. When we match a cons, we combine the $\alpha$ on the cons node itself with the availabilities $\beta$ and $\beta'$ computed for $v$ and $v'$. Non-empty records are similar, but to process the initial part of the record, we supply the neutral selection state $\top$ on the subrecord in order to use the definition recursively. (Subrecords are not first-class, but exist only as intermediate artefacts of the interpreter.)

One might hope to dispense with the need for $w$ by simply defining $\matchFwdF{w}$ by case analysis on $v$ and $\sigma$. However, it is then unclear how to proceed in the event that $v$ is a hole. It would be legitimate to produce $\hole$ as the output continuation and $\bot$ as the output selection state, but for the output environment to be well-typed, it must provide variable bindings corresponding to those introduced in the baseline computation where $\raw{v}$ was matched against $\raw{\sigma}$. If $\matchFwdS$ is defined with respect to a known $w$, this can be achieved via an additional rule \ruleName{$\matchFwdS$-hole-1} that defines the behaviour at hole to be the same as the behaviour at any $\eq$-equivalent value, where the $\raw{v}$ subscript on $\eq$ makes it clear that we are only considering the relation at $\Sel{\raw{v}}{A}$. The \ruleName{$\matchFwdS$-hole-2} makes a similar provision for $\sigma$, which may also be a hole. Operationally, these rules can be interpreted as ``expanding'' enough of the holes in $v$ or $\sigma$ to make another rule of the definition match; there will be exactly one non-hole rule that matches, corresponding to the execution path originally taken, and although there may be multiple such expansions, the result of $\matchFwdF{w}$ will be unique up to $\eq$.

\begin{lemma}[Determinism of $\matchFwdF{w}$]
   Suppose $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$, with $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\subsubsection{Forward evaluation}

\figref{data-dependencies:fwd} also defines a family of \emph{forward-evaluation} functions $\evalFwdF{T}$ of type $\Sel{\raw{\rho}, \raw{e}}{A} \times \Ann{A} \to \Sel{\raw{v}}{A}$ for any $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$. Like forward-match, forward-evaluation is presented in a relational style, but should be understood as a total function defined by structural recursion on $T$. Forward evaluation replays $T$, using the input selection $\rho, e \in \Sel{\raw{\rho}, \raw{e}}{A}$ to determine an output selection $v \in \Sel{\raw{v}}{A}$. The rules mirror those of the evaluation relation $\evalR$, although there is an additional selection state input $\alpha$ called the \emph{ambient availability}. We explain this with reference to the application rule, which is the only point where a new ambient availability is assigned.

The rule assumes the application $\exApp{e}{e'}$ already has an ambient availability $\alpha$; at the outermost level this will usually be $\top$. The rule passes $\alpha$ down when recursively forward-evaluating $e$ and $e'$, but computes a new selection state $\beta$ when transferring control to the function. The $\beta$ is obtained by forward-matching the argument $v$ with the eliminator $\sigma$ of the closure, and thus represents the availability of those parts of $v$ demanded by the function. The ambient availability is used to bound the availability of any selectable values constructed in the dynamic context of that function, establishing a dependency between the resources consumed by functions and resources they produce.

All other rules pass the ambient availability into any subcomputations unchanged. The variable, lambda and letrec rules do not directly produce or consume any (selectable) resources, and so disregard the ambient availability $\alpha$ entirely, although they preserve any selections internal to the subvalues they manipulate. Record projection is more interesting, disregarding not only the ambient $\alpha$ but also the selection state $\beta$ of the record itself. Containers are considered to be independent of the values they contain: here, $v_i$ has its own internal selections which are preserved by projection, but there is no implied dependency of the field on the record from which it was projected. Record construction also reflects this principle, by simply transferring the selectable value for each field into the constructed record unchanged. But it also sets the selection state of the record value to be the meet of $\alpha$ and $\alpha'$, reflecting the dependency not only on the constructing expression but also on any resources demanded by the ambient function. The rules for nil, cons and integers are similar.

Primitive operations are the other source of input-output dependencies beyond user-defined functions. Since a primitive operation is opaque, these dependencies cannot be derived from its execution, but must be specified by the primitive operation directly. More specifically, $\phi \in \tyInt^{i} \to \tyInt$ is required to provide a forward-dependency function $\primFwdBool{\phi}{\vec{n}}: \Ann{A}^i \toÂ \Ann{A}$ for every $\vec{n}$ of length $i$ which specifies how to turn an input selection $\vec{\alpha} \in \Ann{A}^i$ for $\vec{n}$ into an output selection $\alpha'$ on $\exAppPrim{\phi}{\vec{n}}$. There is one such function per possible input $\vec{n}$, since the dynamic dependencies for a primitive operation with an annihilator, such as multiplication, depend on the values passed to the operation. Primitives are free to implement forward-dependency however they want; however, \secref{data-dependencies:analyses:bwd:eval} will also require $\phi$ to provide a backward-dependency function for any input $\vec{n}$, and the two must form an adjoint pair for the consistency of the whole system to be guaranteed.

The hole rule for $\evalFwdF{T}$ is similar to the rules for $\matchFwdF{w}$, except that no special treatment is needed for the holes that arise inside $\rho$, and environments themselves have no special $\hole$ form. Moreover, the elimination rules (application and record projection) must accommodate the case where the selectable value being eliminated (closure or record) is represented by $\hole$. In these rules $\evalFwdR{T}\eq$ denotes the relational composition of $\evalFwdR{T}$ and $\eq$. As with $\matchFwdF{w}$, these uses of $\eq$ can be understood operationally as using the information in $T$ to expand $\hole$ sufficiently for the rule to apply, with a result which is unique up to $\eq$.

\begin{lemma}[Determinism of $\evalFwdF{T}$]
   Suppose $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$ with $\rho, e, \alpha \evalFwdR{T} v$ and $\rho', e', \alpha \evalFwdR{T} v'$. If $(\rho, e) \eq (\rho', e')$ then $v \eq v'$.
\end{lemma}

\subsection{Backward data dependency}
\label{sec:data-dependencies:analyses:bwd}

Backward analysis ``rewinds'' evaluation, propagating selections from outputs to inputs, with $T$ guiding the analysis backward.

\subsubsection{Backward matching}
\label{sec:data-dependencies:analyses:bwd:pattern-match}

\figref{data-dependencies:bwd} defines a family of \emph{backward-match} functions $\matchBwdF{w}$ of type $\Sel{\raw{\rho}, \raw{\kappa}{A}} \times \Ann{A} \to \Sel{\raw{v}, \raw{\sigma}}{A}$ for any $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$. Backward-match rewinds the match witnessed by $w$, propagating selections on the continuation and execution environment back onto the value and eliminator that were originally matched. The additional argument $\alpha$ represents demand placed on the matched portion of $\raw{v}$ by the downstream computation.

In the variable case, no proper part of $\raw{v}$ was matched, so $\alpha$ is disregarded. The rule need only ensure that the demand $v$ captured in the singleton environment $\bind{x}{v}$ is propagated backward. If a Boolean constant was matched, $\alpha$ becomes the demand on that constant, and $\kappa$, capturing the demand on the continuation, becomes the demand on the taken branch of the original eliminator. The non-taken branch is fully unselected. Using $\hole$ for this means matches $w$ need only retain information about taken branches. The nil case is similar.

For a cons match $\matchCons{w}{w'}$, we split the environment into $\rho$ and $\rho'$ (there is a unique well-typed decomposition) and then backward-match $w$ and $w'$ recursively to obtain $v$ and $v'$, representing the demand on the head and tail of the list. These are combined into the demand on the entire list, using $\alpha$ as the demand on the cons node. $\sigma$ represents the demand on the interim eliminator used to match the tail, and $\tau$ the demand on the eliminator used to match the head, which are then combined into an demand on the eliminator used to match the whole list, with $\hole$ again used to represent the absence of demand on the nil branch. Records are similar, except there is only a single branch, and the selection state $\beta$ computed for the initial part of the record is an artefact of processing records recursively, and can be disregarded.

\subsubsection{Backward evaluation}
\label{sec:data-dependencies:analyses:bwd:eval}

\figref{data-dependencies:bwd} also defines a family of \emph{backward-evaluation} functions $\evalBwdF{T}$ of type $\Sel{\raw{v}}{A} \to \Sel{\raw{\rho}, \raw{e}}{A} \times \Ann{A}$ for any $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$. Backward evaluation rewinds $T$, using the output selection $v \in \Sel{\raw{v}}{A}$ to determine an input selection $\rho, e \in \Sel{\raw{\rho}, \raw{e}}{A}$. The rules resemble those of the evaluation relation $\evalR$ with inputs and outputs flipped, and with an additional output $\alpha$ called the \emph{ambient demand} representing the join of the demand on any partial values constructed in the current function context. The general pattern is that each backward rule takes the join of any demand attached to the partial values constructed at that step, and the ambient demand associated with any subcomputations, and pass it upwards as the new ambient demand. The output environment is constructed similarly, by joining the demand flowing back through the environments used to evaluate subcomputations.

The application rule is where the ambient demand are used and the current function context ends, so again we start with application. The rule essentially runs the forward evaluation rule in reverse, using the trace $T'$ to backward-evaluate the function body. The obtained $\beta$ is the join of the demand on any resources constructed directly by that function invocation, and is transferred to the matched part of the function argument by backward-matching, establishing a link between resources consumed and resources produced. Backwards evaluation continues in the containing function context, with ambient demand $\alpha \join \alpha'$, representing the resources needed along $T$ and $U$. The family of auxiliary functions $\sub{\closeDefsBwdR}{\rho, h}: \Sel{\raw{\rho'}}{A} \to \Sel{\raw{\rho}, \raw{h}}{A}$ for any $\raw{\rho}, \raw{h} \closeDefsR \raw{\rho'}$ defined at the bottom of \figref{data-dependencies:bwd} is used to turn the closure environment $\rho_2$, capturing the demand flowing back through any recursive uses of the function and any functions with which it was mutually defined, into information that can be merged back into the demand on the closure.

In the variable case, no partial values were constructed during evaluation and there are no subcomputations, so the ambient demand is $\bot$, the unit for $\join$. The returned environment selection demands $v$ for the variable $x$ and $\hole$ for all other variables, using the \emph{backwards lookup} function $\envLookupBwdR{\rho}$ of type $\Sel{\raw{v}}{A} \to \Sel{\raw{\rho}}{A}$ for any $\envLookup{\raw{\rho}}{x}{\raw{v}}$. (The output of the function is on the left in the relational notation.) For atomic values such as integers and nil, the ambient demand is simply the demand $\alpha$ associated with the constructed value, which also becomes the demand attached to the corresponding expression. For composite values such as records and cons cells, the ambient demand has two sources: the ambient demand associated with any subcomputations, plus the demand on the constructed value itself. So for records, for example, each subcomputation produces an ambient demand $\alpha'_i$, and we join these with the demand $\alpha$ on the record itself to produce the ambient demand passed upward. Here $\bigjoin{\vec{\alpha}'}$ means the fold of $\join$, with unit $\bot$, over the sequence of selection states $\seqRange{\alpha_1'}{\alpha_{\length{\vec{x}}}'}$.

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ of length $i$ provide a backward-analysis function $\primBwdBool{\phi}{\vec{n}}: \Ann{A} \to \Ann{A}^i$, which \todo{finish}.

\input{fig/core-language/slicing/eval-bwd}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\subsection{Galois connections}
\label{sec:data-dependencies:analysis:galois-connections}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

We assume (rather than prove) that the forward and backwards dependency functions provided for a primitive operation $\phi: \tyInt^i \to \tyInt$ form a Galois connection between $\Ann{A}^i$ and $\Ann{A}$, i.e.~that $\primFwdBool{\phi}{\vec{n}} \adjoint \primBwdBool{\phi}{\vec{n}}$.

\begin{theorem}[Galois connection for pattern-matching]
   \label{thm:core-language:match:gc}
      Suppose $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}

\ifappendices
   \begin{proof}
   \appref{proofs:core-language:match:gc}
   \end{proof}
\fi

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}
