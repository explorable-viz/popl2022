\subsection{Galois dependency}
\label{sec:data-dependencies:analyses}

We now show how to interpret a selection on a program $\raw{e}$ or its environment $\raw{\rho}$ (collectively: an \emph{input selection}) as a selection on its output $\raw{v}$, and vice versa. In the forward direction, we will think of input selections as (non-linear) \emph{resources} available for use, giving rise to output selections indicating the resources available to a downstream computation because they depend only on selected input. In the backward direction, output selections represent resources being demanded by a downstream computation, giving rise to input selections identifying the resources needed for the selected output. Both analyses are with respect to a fixed computation $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$, where $T$ is a trace. (Typically one would first evaluate a program to obtain its trace $T$, and then run a forward or background analysis over $T$ with an appropriate lattice.) We call our analysis \emph{Galois dependency}, because the two directions form a Galois connection, a pair of functions that are each other's closest approximate inverse: from above in one direction, from below in the other (\secref{data-dependencies:analysis:galois-connections}).  We present the forward direction first and explain the underlying principles.

\subsection{Forward Galois dependency}

Forward analysis ``replays'' evaluation, propagating annotations from inputs to outputs, with $T$ guiding the analysis whenever when holes in the annotated program would mean the analysis would otherwise get stuck. Pattern-matching introduces the idea of a selection as a set of resources available to a downstream computation, so we start with that.

\input{fig/core-language/slicing/eval-fwd}

\subsubsection{Pattern-matching}

\figref{data-dependencies:fwd} defines the family of forward-analysis functions $\matchFwdF{w} :: \Sel{v, \sigma}{A} \to \Prod{\Sel{\rho, \kappa}{A}}{\Ann{A}}$ for any $w :: \raw{v}, \raw{\sigma} \matchR \raw{\rho}, \raw{\kappa}$, pronounced ``match-forward''. (This is presented in a relational style for readability, but should be understood as a total function defined by structural recursion on $w$.) Match-forward ``replays'' the pattern-match witnessed by $w$, transferring the annotations on the relevant parts of $v \in \Sel{v}{A}$ to the output environment $\rho \in \Sel{\rho}{A}$, and from the relevant part of $\sigma \in \Sel{\sigma}{A}$ to the selected continuation $\kappa \in \Sel{\kappa}{A}$.

$\matchFwdF{w}$ also returns the \emph{meet} of the annotations on the part of $v$ consumed by $\sigma$, which we call the \emph{availability} of $v$, since it represents the extent to which the demand implied by $\sigma$ was met. A variable match consumes nothing of $v$ and so the availability is always $\top$, the unit for meet. A Boolean match consumes either $\annot{\exTrue}{\alpha}$ or $\annot{\exFalse}{\alpha}$, and the availability is simply $\alpha$. Empty list and empty record matches are similar. When we match a cons, we combine $\alpha$ on the cons node itself with the availabilities $\beta$ and $\beta'$ of $v$ and $v'$; non-empty records are similar. When we recurse into the rest of the record, we supply $\bot$ as the annotation on the subrecord; it would be redundant to pass $\alpha$. (Subrecords are not first-class, but exist only as intermediate artefacts of the interpreter.)

\subsubsection{Evaluation}

The idea of forward dependency analysis is to propagate selections on the input resources in order to determine the selections on the output value. The function $\evalFwdF{T} :: \Prod{\Sel{\rho, e}{A}}{\Ann{A}} \to \Sel{v}{A}$ describes how we take a selected term $e$ and environment $\rho$, along with the selection $\alpha$ of the current context, and consume them to construct the selection information of the output value $v$. When working in the forwards direction, we want to express that a value is only selected if all the terms involved in its construction are selected, hence we use the meet operation to combine selection states.

Evaluating a variable $x$ is equivalent to looking it up in the environment $\rho$, except that value obtained may contain annotations. Anonymous functions $\exLambda{\sigma}$ simply evaluate to closures, which are unannotated. We begin to see how the $\meet$ operation is used when evaluating an integer $n_{\alpha'}$ with $\alpha$ as the current selection context - this returns $\annot{n}{\alpha \meet \alpha'}$, expressing that the value $n$ is selected if both the term $n$ and the term containing $n$ were selected. The same logic applies to empty lists $\annot{\exNil}{\alpha'}$.

The recursive behaviour of forward analysis is first seen in the rule for records, $\exRec{\vec{\bind{x}{e}}}_{\alpha}$. We begin by forward analysing each term $e_i$ in the record to a selected value $v_i$, and then construct a record $\annot{\vec{\bind{x}{v}}}{\alpha \meet \alpha'}$, which is only selected if the record itself was selected along with the current context $\alpha'$.

For the cons rule, $\exPair{(\rho,\annCons{e_1}{e_2}{\alpha'})}{\alpha}$, we forward analyse $e_1$ and $e_2$ to get annotated values $v_1$ and $v_2$, and then construct the value $\annCons{v_1}{v_2}{\alpha \meet \alpha'}$ where the cons constructor is only selected if both $\exCons{e_1}{e_2}$ and the outer term containing it are selected.

% Give the intuition that what we do with annotation propagation is specifying how we consume resources in the input in order to construct things in the output.

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\subsection{Backward Galois dependency}

Backward analysis ``rewinds'' evaluation, propagating annotations from outputs to inputs, with $T$ guiding the analysis backward.

\subsubsection{Pattern-matching}

The function $\matchBwdF{w} :: \Prod{\Sel{\rho, \kappa}{A}}{\Ann{A}} \to \Sel{v, \sigma}{A}$ can also be understood in two parts. First, we use the match $w$ to reconstruct the shape of the eliminator $\sigma$. The environment $\rho$ and continuation $\kappa$ resulting from the forward pattern-match are then used to determine the original continuation for the branch corresponding to $w$; all other branches are considered unused and hence have hole as their continuations. Second, we take the output selection $\alpha$ which tells us if all input resources were available when forward matching, and use this to annotate the original input value $v$.

The rule for variables $\matchVar{x}$, discards its output selection $\alpha$ as no selections were originally consumed when forward pattern-matching against a variable eliminator. For matches $w$ representing either $\matchTrue$ or $\matchFalse$, we take the output selection $\alpha$ and use this to annotate the Boolean value corresponding to $w$. The same logic applies to $\matchNil$. For non-empty lists, $\matchCons{w_1}{w_2}$, we backward match in reverse order against the tail pattern $w_2$ then the head pattern $w_1$ to acquire annotated values $v_2$ and $v_1$. Using this, we reconstruct the value $\annCons{v_1}{v_2}{\alpha}$ where the cons constructor is annotated by the output selection $\alpha$. Similarly for records, $\matchRec{\vec{\bind{x}{w}} \concat \bind{y}{w'}}$, we recursively backward match against all of the components of record and annotate the record constructor with the output selection $\alpha$.

\input{fig/core-language/slicing/eval-bwd}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\subsection{Galois connections}
\label{sec:data-dependencies:analysis:galois-connections}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}
