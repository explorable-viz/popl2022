\subsection{Forward and backward Galois dependency}
\label{sec:data-dependencies:analyses}

We now show how to interpret a selection on a program $\raw{e}$ or its environment $\raw{\rho}$ (collectively: an \emph{input selection}) as a selection on its output $\raw{v}$, and vice versa. In the forward direction, we will think of input selections as (non-linear) \emph{resources} available for use, giving rise to output selections indicating those resources that can be made available to a downstream computation, because they depend only on selected input. In the backward direction, output selections represent resources being demanded by a downstream computation, giving rise to input selections which are the resources needed for the selected output.

Both forwards and backwards analyses are performed with respect to a provided fixed computation $T :: \raw{\rho}, \raw{e} \evalR \raw{v}$, where $T$ is a ``trace'' or derivation tree as defined in \figref{core-language:semantics}. Forward analysis ``replays'' evaluation, propagating annotations from inputs to outputs; the trace $T$ is needed to guide forward analysis through the original computation when holes in the annotated program result in loss of information about the program structure. Backward analysis ``rewinds'' evaluation, propagating annotations from outputs to inputs; the role of traces is more obvious here. A typical use case would be to first evaluate a program to obtain its trace $T$ and then run a forward or background analysis over $T$ with an appropriate lattice. We call our analysis \emph{Galois dependency}, because the two directions form a Galois connection, a pair of functions that are each other's closest approximate inverse: from above in one direction, from below in the other (\secref{data-dependencies:analysis:galois-connections}). First we define the two directions and explain the principles underlying the definitions.

\input{fig/core-language/slicing/eval-fwd}

\subsubsection{Pattern-matching}

It is necessary to first describe how the notion of pattern-matching translates to forward and backward dependency analysis, as this is how annotated input values are consumed to determine whether we have all the resources required to construct an output.

The function $\matchFwdF{w} :: \Sel{v, \sigma}{A} \to \Prod{\Sel{\rho, \kappa}{A}}{\Ann{A}}$ for forward analysis pattern-matching defined in \figref{data-dependencies:fwd} can be understood in two parts.
%First, it expresses that we match a value $v$ against an eliminator $\sigma$, both of which are annotated, to produce an annotated environment $\rho$ and continuation $\kappa$.
First it re-expresses the relation $\explVal{w}{v, \sigma \matchR \rho, \kappa}$ (given previously in \figref{core-language:semantics}) except that $v$, $\sigma$, $\rho$, and $\kappa$ are now annotated. Second, we make use of the match $w$ which records the eliminator's pattern we originally matched against. This informs us to take the conjunction of all values in $v$ which correspond to $w$ -- the resulting selection $\alpha$ determines if we have all the input resources necessary for consumption when pattern-matching.

Matching against a variable eliminator $\elimVar{x}{\kappa}$ always returns the selection $\top$, as a variable eliminator can accept any value. For Boolean eliminators, the output selection $\alpha$ is simply the selection on the Boolean value we match with i.e. $\annot{\exTrue}{\alpha}$ or $\annot{\exFalse}{\alpha}$ -- intuitively, if this value is selected then it constitutes all the resources required for the match. This is also the case for $\annot{\exNil}{\alpha}$.

For the non-empty list, $\annListComp{v_1}{v_2}{\alpha}$, we must first determine whether $v_1$ and $v_2$ are available as resources by performing forward match analysis on $v_1$ and $v_2$ as the head and tail pattern against the cons case eliminator $\sigma'$ in $\elimList{\kappa}{\sigma'}$; this returns selections $\beta$ and $\beta'$. We then take the meet of these with the selection $\alpha$ of the cons constructor to yield $\alpha \meet \beta \meet \beta'$. In other words, the output from matching against a non-empty list is only available if the head, tail, and cons constructor are available to match with. A similar story holds for forward-matching against records, where the output is only available if both the record constructor and all of its components are available.

Now working in the backwards direction, the function $\matchBwdF{w} :: \Prod{\Sel{\rho, \kappa}{A}}{\Ann{A}} \to \Sel{v, \sigma}{A}$ can also be understood in two parts. First, we use the match $w$ to reconstruct the shape of the eliminator $\sigma$. The environment $\rho$ and continuation $\kappa$ resulting from the forward pattern-match are then used to determine the original continuation for the branch corresponding to $w$; all other branches are considered unused and hence have hole as their continuations. Second, we take the output selection $\alpha$ which tells us if all input resources were available when forward matching, and use this to annotate the original input value $v$.

The rule for variables $\matchVar{x}$, discards its output selection $\alpha$ as no selections were originally consumed when forward pattern-matching against a variable eliminator. For matches $w$ representing either $\matchTrue$ or $\matchFalse$, we take the output selection $\alpha$ and use this to annotate the Boolean value corresponding to $w$. The same logic applies to $\matchNil$. For non-empty lists, $\matchCons{w_1}{w_2}$, we backward match in reverse order against the tail pattern $w_2$ then the head pattern $w_1$ to acquire annotated values $v_2$ and $v_1$. Using this, we reconstruct the value $\annCons{v_1}{v_2}{\alpha}$ where the cons constructor is annotated by the output selection $\alpha$. Similarly for records, $\matchRec{\vec{\bind{x}{w}} \concat \bind{y}{w'}}$, we recursively backward match against all of the components of record and annotate the record constructor with the output selection $\alpha$.
% what pattern matching is doing is taking the conjunction of all selections on the values in v that correspond to the trace w

% The intuition behind mapping selections on the input to selections on the output is as a resource consumption, and evaluation consumes values and produces values, and the two kinds of consumptions (ways you can consume values) are primitive operations and pattern matching. Whenever we try to construct an output, we need to check that the resources are available. As primitive operations induce demand on their arguments in that in order to produce an output, this means checking that the selection on the required arguments are there. Structured values like lists are consumed by pattern-matching - whether we are able to construct an output depends on whether any data that was consumed in that local context was available.

% Every function operates as a context that consumes some input through its eliminator and all the selections on the consumed input determine whether any values constructed in that context can be constructed.

\subsubsection{Evaluation}

The idea of forward dependency analysis is to propagate selections on the input resources in order to determine the selections on the output value. The function $\evalFwdF{T} :: \Prod{\Sel{\rho, e}{A}}{\Ann{A}} \to \Sel{v}{A}$ describes how we take a selected term $e$ and environment $\rho$, along with the selection $\alpha$ of the current context, and consume them to construct the selection information of the output value $v$. When working in the forwards direction, we want to express that a value is only selected if all the terms involved in its construction are selected, hence we use the meet operation to combine selection states.

Evaluating a variable $x$ is equivalent to looking it up in the environment $\rho$, except that value obtained may contain annotations. Anonymous functions $\exLambda{\sigma}$ simply evaluate to closures, which are unannotated. We begin to see how the $\meet$ operation is used when evaluating an integer $n_{\alpha'}$ with $\alpha$ as the current selection context - this returns $\annot{n}{\alpha \meet \alpha'}$, expressing that the value $n$ is selected if both the term $n$ and the term containing $n$ were selected. The same logic applies to empty lists $\annot{\exNil}{\alpha'}$.

The recursive behaviour of forward analysis is first seen in the rule for records, $\exRec{\vec{\bind{x}{e}}}_{\alpha}$. We begin by forward analysing each term $e_i$ in the record to a selected value $v_i$, and then construct a record $\annot{\vec{\bind{x}{v}}}{\alpha \meet \alpha'}$, which is only selected if the record itself was selected along with the current context $\alpha'$.

For the cons rule, $\exPair{(\rho,\annCons{e_1}{e_2}{\alpha'})}{\alpha}$, we forward analyse $e_1$ and $e_2$ to get annotated values $v_1$ and $v_2$, and then construct the value $\annCons{v_1}{v_2}{\alpha \meet \alpha'}$ where the cons constructor is only selected if both $\exCons{e_1}{e_2}$ and the outer term containing it are selected.

% Give the intuition that what we do with annotation propagation is specifying how we consume resources in the input in order to construct things in the output.

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\input{fig/core-language/slicing/eval-bwd}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\subsection{Galois connections}
\label{sec:data-dependencies:analysis:galois-connections}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}
