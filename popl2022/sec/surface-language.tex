\newpage
\section{Extending to a realistic surface language}
\label{sec:surface-language}

Up until now we have primarily considered how to track dependencies between input and output values, however, our approach also allows us to inspect selections on terms themselves to determine which fragments of our program are involved in the construction of a value. The ability to do this is not restricted to programs written using the core calculus given in \secref{core-language} -- one may want to observe how data dependencies interact with more sophisticated language constructs, such as list comprehensions and piece-wise definitions.

To achieve this, it is unnecessary to augment our core language to accommodate for every new syntactic form and their forward and backward dependency semantics -- we can instead create a surface language on top of our core language. The translation between our surface and core language then gives rise to another Galois connection. In the \textit{forward} direction, we desugar surface terms in their equivalent core representation whilst preserving their selection information. Conversely, in the \textit{backward} direction we reconstruct the original surface term from the core term whilst translating the selection information backward. The Galois connection for desugaring then composes with the Galois connection for dependency analysis in \secref{data-dependencies:analyses}, allowing our approach for data linking to easily extend to tracking dependencies between outputs and programs written in the surface language. In this section, we demonstrate how this can be achieved for a small program (\figref{surface-language:example-1}) written in our example surface language.

\input{fig/surface-language/syntax}

\subsection{Surface language syntax}

Consider the program selection in \figref{surface-language:example-1}; the program uses list comprehensions to iterate through a list of records containing fields $\texttt{country}$ and $\texttt{output}$, and constructs a list of tuples containing countries and their total energy output. Assuming the output of this program were $\texttt{[("China", 304), ("USA", 125),}$ $\texttt{("Germany", 606)]}$, one could be interested in how selecting the string $\texttt{"China"}$ places a demand on list comprehensions and other constants that occur in the surface program as resources.

\begin{figure}[H]
\small
\begin{lstlisting}
let totalFor c rows = sum [ row.output | row $\leftarrow$ rows, row.country == c ]$_{\alpha_1}$
in  [ (c , totalFor c data)$_{\beta_1}$ | c $\leftarrow$ ["China"$_{\beta_2}$ ,$_{\beta_3}$ "USA"$_{\beta_4}$ ,$_{\beta_5}$ "Germany"$_{\beta_6}$ ]$_{\beta_7}$ ]$_{\alpha_2}$
\end{lstlisting}
\caption{List comprehension example: Surface language}
\label{fig:surface-language:example-1}
\end{figure}

\noindent
The full surface language syntax used to write this program and others in the paper is presented in \figref{surface-language:syntax} for completeness, however, here we focus primarily on list comprehensions and list notation. Surface terms are denoted by $s, t$; in particular, lists can now be written in the style $\kw{[} s \comma \ldots \comma s' \kw{]}$ using the term $\annList{s}{r}{\alpha}$, where $r$ either recursively defines the rest of the list, $\annListNext{s}{r}{\alpha}$, or is the end of the list, $\annListEnd{\alpha}$. List comprehensions, $\annListComp{s}{\vec{q}}{\alpha}$, then consist of a body $s$ which is constructed in reference to the environment introduced by a sequence of ``qualifiers'' $\vec{q}$. There are three variants of qualifiers: \textit{guards}, $\qualGuard{s}$, which enforce a Boolean condition $s$ to be true, \textit{generators}, $\qualGenerator{p}{s}$, which iterate through each of the elements in a list $s$ and binds them to a pattern $p$, and \textit{declarations}, $\qualDeclaration{p}{s}$, which bind an arbitrary term $s$ to $p$. We will only consider the first two forms for the purposes of \figref{surface-language:example-1}. It can be noted that the terms for lists and list comprehensions have selections because they correspond to selectable values i.e. $\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$.

\subsection{Forward desugaring}

Desugaring in the forwards direction is given by the relation $s \desugarFwdR e$ in \figref{desugar-fwd-short} which specifies how to desugar a surface language term $s$ into its equivalent core language form $e$, whilst correctly retaining the selection information made on $s$.

\input{fig/surface-language/slicing/desugar-fwd-short.tex}

\noindent
The rules for nil $\annNil{\alpha}$ and other constants simply preserve their selected form. For cons $\annCons{s}{s'}{\alpha}$ and non-empty lists $\annList{s}{r}{\alpha}$, we recursively desugar all elements of the list and translate any sugared list constructors $\kw{[}_\alpha$, $\kw{,}_{\alpha}$, and $\kw{]}_{\alpha}$, to their core representations $\kw{(:)}_{\alpha}$ or $\annNil{\alpha}$. Desugaring the pair constructor behaves the same as cons. List comprehensions, $\annListComp{s}{\vec{q}}{\alpha}$, are slightly more involved; each of the rules accounts for a different possible qualifier at the head of the sequence $\vec{q}$.

When the first qualifier in a list comprehension is a generator $\qualGenerator{p}{s'}$, we want to elaborate $\annListComp{s}{\qualGenerator{p}{s'} \concat \vec{q}}{\alpha}$ into a function which maps over each element in the generator list $s'$. If the element matches the pattern $p$, the ``rest'' of the list comprehension should be returned; otherwise an empty list $\annNil{\alpha}$ with the selection of the original list comprehension is returned. The end result is a list of lists which then needs to be flattened. We achieve this by first desugaring the rest of the list comprehension $\annListComp{s}{\vec{q}}{\alpha}$ to obtain $e$, and desugaring the generator list $s'$ to obtain $e'$. The operation $p, e \clauseFwdR \sigma$ then constructs a singleton eliminator $\sigma$ where matching against $p$ returns $e$ as its continuation. To account for elements in the generator list which may not match against $p$, we must ensure that our eliminator is total; hence the \textit{totalise} operation $\totaliseFwd{\sigma}{\alpha}{p}{\sigma'}$ takes $\sigma$ and a selection $\alpha$ and recursively inserts a synthesised branch with body $\annNil{\alpha}$ for each missing case in $\sigma$. This returns us a \textit{total} eliminator $\sigma'$. The final desugared form is given by the application $\funConcatMap \; \exLambda{\sigma'} e'$, where $\funConcatMap$ first maps $\exLambda{\sigma'}$ over the generator list $e'$ to produce a list of lists, and then flattens it.

When the first qualifier in a list comprehension is a guard, $\qualGuard{s'}$, the process of desugaring is similar. We elaborate $\annListComp{s}{\qualGuard{s'} \concat \vec{q}}{\alpha}$, by again desugaring the rest of the list comprehension $\annListComp{s}{\qualGuard{s'} \concat \vec{q}}{\alpha}$ to $e$, and the Boolean condition $s'$ to $e'$. The idea is then to construct a Boolean eliminator and apply it to $e'$: if the condition $e'$ holds, the eliminator should return the rest of the list comprehension $e$, otherwise it returns an empty list $\annNil{\alpha}$ with the selection $\alpha$ of the original list comprehension.

If the sequence of qualifiers in the list comprehension is empty, i.e. $\annListComp{s}{\seqEmpty}{\alpha}$, then we simply desugar its body $s$ into $e$ and cons it to an empty list. This results in $\annCons{e}{\annNil{\alpha}}{\alpha}$ where the original selection $\alpha$ is propagated onto both the cons constructor and empty list.

\begin{figure}[H]
\small
\begin{lstlisting}
let totalFor c rows =
      sum (concatMap $\exLambda{\{\elimVar{\kw{row}}{  \exLambda{\elimBool{ \kw{(} \annCons{\kw{row.output}}{\annNil{\alpha_1}}{\alpha_1} \kw{)} }{\annNil{\alpha_1}}} \; \kw{(row.country == c)} }\}}$ rows)
in  concatMap $\exLambda{\{\elimVar{\kw{c}}{ \kw{(} \annCons{\kw{(c, totalFor c data)}_{\beta_1}}{\annNil{\alpha_2}}{\alpha_2} \kw{)}  }\}}$ ["China"$_{\beta_2}$,$_{\beta_3}$ "USA"$_{\beta_4}$,$_{\beta_5}$ "Germany"$_{\beta_6}$]$_{\beta_7}$
\end{lstlisting}
\caption{List comprehension example: Surface language forwards desugared}
\label{fig:surface-language:example-4}
\end{figure}

\noindent
Desugaring the surface language program in \figref{surface-language:example-1} with these rules yields the core program in \figref{surface-language:example-4}. We can see that the selections $\alpha_1$ and $\alpha_2$ on the original list comprehensions have been propagated and the selections on constants and the pair constructor have been preserved.

\subsection{Backward desugaring}

In order to desugar backwards, we need something that plays the role of a trace (as in backward evaluation analysis in \secref{data-dependencies:analyses:bwd}). For desugaring, its sufficient to use the original program and allow the trace $t$ to range over raw surface language terms $s$. The relation for backward desugaring, $e \desugarBwdR{t} s$, is then given in \figref{desugar-bwd-short} and is defined by recursion over $t$. This says that the core term $e$ can be desugared backwards over a trace $t$ to its original surface representation $s$, where $t$ corresponds to the unselected form of $s$.

\input{fig/surface-language/slicing/desugar-bwd-short.tex}

The rule for nil $\annNil{\alpha}$ and other constants simply preserve the selection state. For non-empty lists, $\annCons{e}{e'}{\alpha}$, we recursively backward desugar the head and tail of the list and use its trace, $\exCons{t}{t'}$ or $\exList{t}{r}$, to determine the original list constructor used in its surface representation. The rules for list comprehensions use the join operation to combine selections; this expresses that if any of the terms that list comprehensions desugar into are needed as resources, then the original list comprehension is also needed.

For list comprehensions with a generator as their first qualifier, we backward desugar the term $\exApp{\exApp{\funConcatMap}{\exLambda{\sigma}}}{e}$ with respect to trace $\exListComp{t'}{\qualGenerator{p}{t} \concat \vec{q}}$. First, we recover the surface representation $s$ of the list generator $e$. The operation $\totaliseBwd{\sigma}{p}{\sigma'}{\beta}$ then transforms our total eliminator $\sigma$ into a singleton eliminator $\sigma'$ containing the branch for pattern $p$; it also returns $\beta$ which represents the demand placed on the synthesized branches of $\sigma$ (which were produced by \textit{totalise}). Afterwards, $\sigma' \clauseBwdR{p} e'$ extracts the body $e'$ from the singleton eliminator $\sigma'$, which then desugars into the ``rest'' of the list comprehension $\annListComp{s'}{\vec{q}'}{\beta'}$ without the generator qualifier. By inserting the generator $\qualGenerator{p}{s}$ into this, we recover the original surface term $\annListComp{s'}{\qualGenerator{p}{s} \concat \vec{q}'}{\beta \join \beta'}$, where we annotate it by the join of all intermediate selections produced.

A similar process applies for list comprehensions with guards, where we backward desugar the core term $\exApp{\exLambda{\elimBool{e}{\annNil{\alpha}}}}{e'}$ over the trace $\exListComp{t}{\qualGuard{t'} \concat \vec{q}}$. The surface Boolean $s'$ is recovered from $e'$ and represents the guard's condition. The rest of the list comprehension without the guard, $\annListComp{s}{\vec{q}'}{\beta}$, is then recovered from backward desugaring the body $e$ of the Boolean eliminator's $\exTrue$ branch. Inserting the guard $\qualGuard{s'}$ into this list comprehension yields the final surface term $\annListComp{s}{\qualGuard{s'} \concat \vec{q}'}{\alpha \join \beta}$, which is annotated by the join of the selections found on each branch of the Boolean eliminator it originally desugared to.

Lastly, we can reconstruct a list comprehension with an empty qualifier sequence by backward desugaring the singleton list $\annCons{e}{\annNil{\alpha}}{\alpha'}$ with respect to the trace $\exListComp{t}{\seqEmpty}$. We first recursively backward desugar $e$ to obtain $s$, the body of the original list comprehension. We use this to return $\annListComp{s}{\seqEmpty}{\alpha \join \alpha'}$, annotated by the join of the selections on the cons and nil constructors in its core representation.

\begin{figure}[H]
\small
\begin{lstlisting}
let totalFor c rows = sum [ row.output | row $\leftarrow$ rows, row.country == c ]$_{\alpha_1 \join \alpha_1 \join \alpha_1}$
in  [ (c ,$_{\beta_1}$ totalFor c data) | c $\leftarrow$ ["China"$_{\beta_2}$ , "USA"$_{\beta_3}$ , "Germany"$_{\beta_4}$ ] ]$_{\alpha_2 \join \alpha_2}$
\end{lstlisting}
\caption{List comprehension example: Core language backwards desugared}
\label{fig:surface-language:example-5}
\end{figure}

\noindent
As an example, the core program given in \figref{surface-language:example-4} backward desugars to \figref{surface-language:example-5}. We can see that where the selections on each list comprehension is the join of the selections on the components it desugared to. (For continuity reasons from \figref{surface-language:example-4}, selections $\alpha_1 \join \alpha_1 \join \alpha_1$ and $\alpha_2 \join \alpha_2$ are trivially joins over the same annotations, however, the same reasoning applies for arbitrary selections).

\begin{definition}[Disjoint join of partial continuations]
   Define $\disjjoin$ to be the smallest partial symmetric function satisfying the equations in \figref{surface-language:disjoin-join-elim}.
\end{definition}

\begin{definition}[Forward and backward functions for desugaring]
     Suppose $s \desugarFwdR e$. Define $\desugarFwdF{s}: \Below{s} \to \Below{e}$ and $\desugarBwdF{s}: \Below{e} \to \Below{s}$ to be $\desugarFwdR$ and $\desugarBwdR{s}$ domain-restricted to $\Below{s}$ and $\Below{e}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for desugaring]
  \label{thm:surface-language:desugar:gc}
     Suppose $s \desugarFwdR e$. Then $\desugarFwdF{s} \adjoint \desugarBwdF{s}$.
\end{theorem}

% \begin{enumerate}
%    \item Refer back to previous section (e.g. explain that using the core-language directly can be inconvenient for tracking more interesting data dependencies).
%    \item Build on top of previous section by motivating the necessity for a surface language which desugars into the core language by giving an example of a program which uses desired language features (such as list comprehensions (w/ generators), clauses, totalise, ).
%    \item Use this example to introduce the syntactic constructs required in the surface language (\figref{surface-language:syntax}), and mention which syntactic forms require annotations. If necessary, explain the corresponding type rules (\figref{surface-language:typing-term}).
%    \item Afterwards, we explain that the implementation needs to capture not only the typical desugaring process of general languages, but acts as an extra bidirectional stage on top of the bidirectional analysis of the core language.
%    \begin{enumerate}
%       \item In the forwards direction, it must specify how annotations on surface language expressions can be correspondingly positioned on the core language expressions that they desugar to.
%       \item In the backwards direction, it must use the original surface-language expression as a trace t in order to reconstruct the original surface-level program. It must also specify how annotations on the core language propagate backwards to form annotations on the surface language.
%    \end{enumerate}
%    \item Explain the forward desugaring of our example in chronological order, making reference to and elaborating on the necessary forward desugaring rules when necessary for terms (\figref{desugar-fwd}) and clauses (\figref{clause-fwd}), and also totalise (\figref{totalise-fwd}).
%    \item Explain how we backward desugar from the core-language version of our example over the forward-trace form in chronological order to reconstruct the original surface-level program. Make reference to and elaborate on the necessary backward rules - for terms (\figref{desugar-bwd}), clauses (\figref{clause-bwd}), and totalise (\figref{totalise-bwd}).
% \end{enumerate}
