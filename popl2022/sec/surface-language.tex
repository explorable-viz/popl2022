\newpage
\section{Galois connections for desugaring}
\label{sec:surface-language}

\todo{Core language serves as a useful ``core'' language but lacks realistic features} So far we have primarily focused on tracking dependencies between values. However, the analysis in \secref{data-dependencies} also assigns selection states to the terms responsible for introducing data. This could, for example, be used in an IDE to links parts of outputs to relevants code fragments, but only if we are able to map those term selections back to the surface program. Then we could retain the benefits of factoring advanced language features through a core dependency-tracking calculus, while preserving the user's ability to understand the results of the analysis in terms of the surface language. In this section we briefly introduce the surface language \OurLanguage{} used in the rest of the paper, and sketch a bidirectional desugaring procedure which maps selections between the two languages.

%The Galois connection for desugaring then composes with the Galois connection for dependency analysis in \secref{data-dependencies:analyses}.

\input{fig/surface-language/syntax}

\subsection{Surface language syntax}

The surface language \OurLanguage{} extends the core language with list notation $\kw{[} s \comma \ldots \comma s' \kw{]}$, Haskell 98-style list comprehensions \cite{peytonJones03}, list enumerations, first-class primitives and piecewise function definitions. The features unique to surface terms $s, t$ are given in \figref{surface-language:syntax}. Raw surface terms $\raw{s}$, $\raw{t}$ (where the type of selections is the unit lattice $\Unit$) are written in bold. \figref{surface-language:example-1} gives an example of how value selections are mapped back to core terms, and thence to surface terms. (The example is somewhat contrived in including the library function \kw{map} and some raw data in the same source file.)

On the left, the user selects the first cons cell (green) in the output; by backwards evaluating and then backwards desugaring, we are able to highlight the list comprehension, the cons that occurs in the second equation of \kw{map}, and the two occurrences of the constant \kw{"Hydro"}. These last two are highlighted because that cell in the output was constructed by eliminating a Boolean value that was constructed by the primitive $\kw{==}$ operator, which consumed the two strings. On the basis of this feedback a  user might conjecture that the two constants \kw{"Geo"} were somehow responsible for the inclusion of the third cons cell in the output, which they can confirm by making the green selection on the right.

\begin{figure}
   \begin{subfigure}{0.48\textwidth}
      \small
      \lstinputlisting[language=Fluid,escapeinside={(*@}{@*)}]{fluid/source-highlighting-1.fld.mod}
   \end{subfigure}
   \hfill
   \begin{subfigure}{0.48\textwidth}
      \small
      \lstinputlisting[language=Fluid,escapeinside={(*@}{@*)}]{fluid/source-highlighting-2.fld.mod}
      \end{subfigure}
   \caption{Source selections (yellow) resulting from selecting different list cells (green)}
\label{fig:surface-language:example-1}
\end{figure}

where $r$ either recursively defines the rest of the list, $\annListNext{s}{r}{\alpha}$, or is the end of the list, $\annListEnd{\alpha}$. The expression forms for lists and list comprehensions have selection states because they correspond to selectable values i.e.~$\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$; list enumerations do not because they desugar to a function application.

\subsection{Forward desugaring}

We define a family of \textit{forward desugaring} functions $\desugarFwdF{t}: \Sel{\raw{s}}{A} \to \Sel{\raw{e}}{A}$ which elaborate surface terms to core terms whilst maximally preserving selection information. The full definition is \ifappendices given in \appref{surface-language} \else \IncludedWithSupplementaryMaterial \fi; \figref{surface-language:desugar} gives a representative selection of the rules. Forward desugaring follows a similar pattern to the meet-preserving forward evaluation function defined in \secref{data-dependencies:analyses:fwd}: the basic principle is for each rule to take the meet of the selection states on any parts of $s$ being consumed, and using that as the selection state for any parts of $e$ being generated at that step.

\begin{figure}
   \input{fig/surface-language/slicing/desugar-short.tex}
   \caption{Forwards and backwards desugaring (selected rules only)}
   \label{fig:surface-language:desugar}
\end{figure}

List notation is entered by the syntactic form $\annList{s}{r}{\alpha}$ and exited by $\annListEnd{\alpha}$. The selection states $\alpha$ on the opening and closing brackets are mapped to the first cons and the nil of the resulting list, and those on intervening elements $\annListNext{s}{r}{\alpha}$ are mapped to the corresponding cons. List comprehensions, $\annListComp{s}{\vec{q}}{\alpha}$, are slightly more involved, with a rule for each possible qualifier at the head of the sequence $\vec{q}$, plus a rule for the case when $\vec{q}$ is empty. The general pattern is to push the selection state on the list comprehension itself through recursively, so it ends up on all core terms generated during the elaboration of the comprehension, such as the \kw{false} branch in the \ruleName{$\desugarFwdR$-list-comp-guard} case and the construction of the singleton list in the \ruleName{$\desugarFwdR$-list-comp-guard} case.

The \ruleName{$\desugarFwdR$-list-comp-gen} case is the most complex case because we have to synthesise an eliminator from the pattern $p$, with a single branch whose body is the desugaring of the rest of the comprehension. This is achieved by the $\vec{p}, e \clauseFwdR \sigma$ judgment (not shown). The resulting $\sigma$ must be made total so that it returns the empty list for any values which do not match $p$ (so it is an appropriate argument to \kw{concatMap}); this is achieved by the $\totaliseFwd{\sigma}{\alpha}{p}{\sigma'}$ judgment (also omitted), where the $\alpha$ specifies the selection state of any synthesised empty lists. The $\clauseFwdR$ is also used in the \ruleName{$\desugarFwdR$-list-comp-decl} case and (in a more general form taking a sequence $\vec{p}$ of patterns) to elaborate piecewise definitions of curried functions.

\subsection{Backward desugaring}

To desugar backwards, we define a family of \textit{backward desugaring} functions $\desugarBwdR{\raw{t}}: \Sel{\raw{e}}{A} \to \Sel{\raw{t}}{A}$ for any $\raw{t} \desugarR \raw{e}$ which uses the original raw surface term $\raw{t}$ to guide the analysis backwards. (The role of $\raw{t}$ is disambiguating the backwards rules should be clear by considering that $e$ will typically match multiple rules but only one for a given $\raw{t}$.) \figref{surface-language:desugar} gives some representative rules; the full definition is {\ifappendices given in \appref{surface-language} \else \IncludedWithSupplementaryMaterial.\fi} When reversing a desugaring step, the guiding principle is to take the join of the selection states of any core syntax constructed by this step, and use that as the selection state on the original surface syntax, turning demand on the core term into (minimal) demand on the surface term. Thus the effect of the list comprehension rules and auxiliary judgements is to set the demand on the comprehension itself to be the join of the demand of all the syntax generated during the elaboration of the comprehension. In the \ruleName{$\desugarBwdR{}$-list-comp-gen} case, the $\totaliseFwdR{p}$ used to elaborate a singleton eliminator $\sigma$ into a total one has backwards version $\totaliseBwdR{p}$ which returns the join $\beta$ of the demands on the empty lists synthesised during desugaring.

\subsection{Round-tripping properties}

It is easy to verify that $\desugarFwdF{t}$ and $\desugarBwdF{t}$ are monotonic. Moreover they form an adjoint pair.

\begin{theorem}[Galois connection for desugaring]
  \label{thm:surface-language:desugar:gc}
     Suppose $t \desugarFwdR e$. Then $(\desugarFwdF{t}, \desugarBwdF{t}): \Sel{\raw{e}}{A} \to \Sel{\raw{s}}{A}$ is a Galois connection.
\end{theorem}

\begin{proof}
   \ifappendices See \appref{proofs-surface:desugar:gc}. \else \ProofInSupplementaryMaterial \fi
\end{proof}
