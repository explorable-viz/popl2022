\newpage
\section{Galois connections for desugaring}
\label{sec:surface-language}

\todo{Core language serves as a useful ``core'' language but lacks realistic features} So far we have primarily focused on tracking dependencies between values. However, the analysis in \secref{data-dependencies} also assigns selection states to the terms responsible for introducing data. This could, for example, be used in an IDE to links parts of outputs to relevants code fragments, but only if we are able to map those term selections back to the surface program. Then we could retain the benefits of factoring advanced language features through a core dependency-tracking calculus, while preserving the user's ability to understand the results of the analysis in terms of the surface language. In this section we briefly introduce the surface language \OurLanguage{} used in the rest of the paper, and sketch a bidirectional desugaring procedure which maps selections between the two languages.

%In the \textit{forward} direction, we desugar surface terms in their equivalent core representation whilst preserving their selection information. Conversely, in the \textit{backward} direction we reconstruct the original surface term from the core term whilst translating the selection information backward. The Galois connection for desugaring then composes with the Galois connection for dependency analysis in \secref{data-dependencies:analyses}, allowing our approach for data linking to easily extend to tracking dependencies between outputs and programs written in the surface language. In this section, we demonstrate how this can be achieved for a small program (\figref{surface-language:example-1}) written in our example surface language.

\input{fig/surface-language/syntax}

\subsection{Surface language syntax}

The surface language \OurLanguage{} extends the core language with list notation $\kw{[} s \comma \ldots \comma s' \kw{]}$, Haskell 98-style list comprehensions \cite{peytonJones03}, list enumerations, first-class primitives and piecewise function definitions. The features unique to surface terms $s, t$ are given in \figref{surface-language:syntax}. Raw surface terms $\raw{s}$, $\raw{t}$ (where the type of selections is the unit lattice $\Unit$) are written in bold. \figref{surface-language:example-1} gives an example of how value selections are mapped back to core terms, and thence to surface terms. (The example is somewhat contrived in including the library function \kw{map} and some raw data in the same source file.)

On the left, the user selects the first cons cell (green) in the output; by backwards evaluating and then backwards desugaring, we are able to highlight the list comprehension, the cons that occurs in the second equation of \kw{map}, and the two occurrences of the constant \kw{"Hydro"}. These last two are highlighted because that cell in the output was constructed by eliminating a Boolean value that was constructed by the primitive $\kw{==}$ operator, which consumed the two strings. This feedback might immediately lead to the hypothesis that the two constants \kw{"Geo"} were somehow responsible for the inclusion of the third cons cell in the output, which the user can confirm by making the green selection on the right.

\begin{figure}
   \begin{subfigure}{0.48\textwidth}
      \small
      \lstinputlisting[language=Fluid,escapeinside={(*@}{@*)}]{fluid/source-highlighting-1.fld.mod}
   \end{subfigure}
   \hfill
   \begin{subfigure}{0.48\textwidth}
      \small
      \lstinputlisting[language=Fluid,escapeinside={(*@}{@*)}]{fluid/source-highlighting-2.fld.mod}
      \end{subfigure}
   \caption{Source selections (yellow) resulting from selecting different list cells (green)}
\label{fig:surface-language:example-1}
\end{figure}

where $r$ either recursively defines the rest of the list, $\annListNext{s}{r}{\alpha}$, or is the end of the list, $\annListEnd{\alpha}$. The expression forms for lists and list comprehensions have selection states because they correspond to selectable values i.e.~$\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$; list enumerations do not because they desugar to a function application.

\subsection{Forward desugaring}

We define a family of \textit{forward desugaring} functions $\desugarFwdF{t}: \Sel{\raw{s}}{A} \to \Sel{\raw{e}}{A}$ which elaborate surface terms to core terms whilst maximally preserving selection information. The full definition is \ifappendices given in \appref{surface-language} \else \IncludedWithSupplementaryMaterial \fi; \figref{surface-language:desugar} gives a representative selection of the rules. Forward desugaring follows a similar pattern to the meet-preserving forward evaluation function defined in \secref{data-dependencies:analyses:fwd}: the basic principle is for each rule to take the meet of the selection states on any parts of $s$ being consumed, and using that as the selection state for any parts of $e$ being generated at that step.

\begin{figure}
   \input{fig/surface-language/slicing/desugar-short.tex}
   \caption{Forwards and backwards desugaring (selected rules only)}
   \label{fig:surface-language:desugar}
\end{figure}

List notation is entered by the syntactic form $\annList{s}{r}{\alpha}$ and exited by $\annListEnd{\alpha}$; the selection states on the opening and closing brackets are mapped to the first cons and final nil in the resulting list, and the selection state on any intervening elements $\annListNext{s}{r}{\alpha}$ are mapped to the corresponding cons. List comprehensions, $\annListComp{s}{\vec{q}}{\alpha}$, are slightly more involved, with a rule for each possible qualifier at the head of the sequence $\vec{q}$, plus a rule for the case when $\vec{q}$ is empty. The general pattern is to push the selection state on the list comprehension itself through recursively, so it ends up on all core terms generated during the elaboration of the comprehension, such as the \kw{false} branch in the \ruleName{$\desugarFwdR$-list-comp-guard} case and the construction of the singleton list in the \ruleName{$\desugarFwdR$-list-comp-guard} case.

The \ruleName{$\desugarFwdR$-list-comp-gen} case is the most complex case because we have to synthesise an eliminator from the pattern $p$, with a single branch whose body is the desugaring of the rest of the comprehension. This is achieved by the $\vec{p}, e \clauseFwdR \sigma$ judgment (not shown). The resulting $\sigma$ must be made total so that it returns the empty list for any values which do not match $p$ (so it is an appropriate argument to \kw{concatMap}); this is achieved by the $\totaliseFwd{\sigma}{\alpha}{p}{\sigma'}$ judgment (also omitted), where the $\alpha$ specifies the selection state of any synthesised empty lists. The $\clauseFwdR$ is also used in the \ruleName{$\desugarFwdR$-list-comp-decl} case and (in a more general form taking a sequence $\vec{p}$ of patterns) to elaborate piecewise definitions of curried functions.

\subsection{Backward desugaring}

In order to desugar backwards, we need something that plays the role of a trace (as in the backward evaluation analysis in \secref{data-dependencies:analyses:bwd}). For desugaring, it is sufficient to use the original program and allow the trace $t$ to range over raw surface terms $s$. \figref{surface-language:desugar} gives a family of \textit{backward desugaring} functions $\desugarBwdR{t}$ of type $\Below{e} \to \Below{s}$, where $\desugarBwdR{t}$ is defined by recursion over $t$. These specify how core terms $e \in \Below{e}$ backward desugar over a trace $t$ to recover their surface representation $s \in \Below{s}$, where $t$ corresponds to the unselected form of $s$. During this, the join operation is used to combine selection information; this expresses that if any of the generated terms that $s$ desugared into are needed as resources, then $s$ itself is also needed.

The rule for nil $\annNil{\alpha}$ and other constants simply preserve the selection state. For non-empty lists, $\annCons{e}{e'}{\alpha}$, we recursively backward desugar the head and tail of the list and use its trace, $\exCons{t}{t'}$ or $\exList{t}{r}$, to determine the original list constructor used in its surface representation.

If the trace is of the form $\exListComp{t'}{\qualGenerator{p}{t} \concat \vec{q}}$, then the core term we backward desugar is necessarily of the form $\exApp{\exApp{\funConcatMap}{\exLambda{\sigma}}}{e}$. The syntactic forms that we generated during desugaring consist of the rest of the list comprehension $\annListComp{s'}{\vec{q}'}{\beta'}$ and the branches of $\sigma$ with body $\annNil{\beta}$ which were synthesized by \textit{totalise}. We use this information to reconstruct the surface term $\annListComp{s'}{\qualGenerator{p}{s} \concat \vec{q}'}{\beta \join \beta'}$, combining the demand $\beta$ on the synthesized branches with the demand $\beta'$ on the list comprehension.

When the trace has form $\exListComp{t}{\qualGuard{t'} \concat \vec{q}}$, the core term is necessarily $\exApp{\exLambda{\elimBool{e}{\annNil{\alpha}}}}{e'}$. The syntax generated during desugaring consists of the rest of the list comprehension $\annListComp{s'}{\vec{q}'}{\beta}$ found in the $\exTrue$ branch, and $\annNil{\alpha}$ found in the $\exFalse$ branch. We recover the final surface term $\annListComp{s}{\qualGuard{s'} \concat \vec{q}'}{\alpha \join \beta}$, combining the demand placed on each branch of the Boolean eliminator.

Lastly, the trace $\exListComp{t}{\seqEmpty}$ must necessarily correspond to the core term $\annCons{e}{\annNil{\alpha}}{\alpha'}$. The two forms generated by desugaring were  $\kw{:}_{\alpha'}$ and $\annNil{\alpha}$, so the recovered surface term $\annListComp{s}{\seqEmpty}{\alpha \join \alpha'}$ merges the demand placed on the cons and nil constructors.

\subsection{Round-tripping properties}

It is easy to verify that $\desugarFwdF{t}$ and $\desugarBwdF{t}$ are monotonic. Moreover they form an adjoint pair.

\begin{theorem}[Galois connection for desugaring]
  \label{thm:surface-language:desugar:gc}
     Suppose $t \desugarFwdR e$. Then $(\desugarFwdF{t}, \desugarBwdF{t}): \Sel{\raw{e}}{A} \to \Sel{\raw{s}}{A}$ is a Galois connection.
\end{theorem}

\begin{proof}
   \ifappendices See \appref{proofs-surface:desugar:gc}. \else \ProofInSupplementaryMaterial \fi
\end{proof}
