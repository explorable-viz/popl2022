\newpage
\section{Galois connections for desugaring}
\label{sec:surface-language}

Elaborating a richer surface language into a simpler core language is a common pattern with well known benefits. It can also make it harder to express certain information to the programmer in terms of the surface language. We face this problem with the analysis in \secref{data-dependencies}, which links outputs not only to inputs, but also to expressions responsible for introducing data. We could use such a feature in an IDE to link structured outputs to relevants code fragments, but only if we are able to map those term selections back to the surface program. In this section we sketch a bidirectional desugaring procedure which addresses this, and which composes with the Galois dependency analysis defined in \secref{data-dependencies:analyses}.

\input{fig/surface-language/syntax}

\subsection{Surface language syntax}

The surface language \OurLanguage{} extends the core syntax with list notation $\kw{[} s \comma \ldots \comma s' \kw{]}$, Haskell 98-style list comprehensions \cite{peytonJones03}, list enumerations, first-class primitives and piecewise function definitions, as shown in \figref{surface-language:syntax}. Typing rules are \ifappendices given in \appref{surface-language}, \figrefTwo{surface-language:typing-term}{surface-language:typing-pattern}\else \IncludedWithSupplementaryMaterial\fi. We attach selection states $\alpha$ to (selectable) surface terms $s, t$ that desugar to selectable core terms, and let $\raw{s}$, $\raw{t}$ range over ``raw'' surface terms, which are isomorphic to the selectable terms where the type of selection states is the unit lattice $\Unit$.

\figref{surface-language:example-1} shows how the end-to-end mapping would appear to a user. (For illustrative purposes the library function \kw{map} and some raw data are included in the same source file.) On the left, the user selects the first cons cell (green) in the output; by backwards evaluating and then backwards desugaring, we are able to highlight the list comprehension, the cons in the second equation of \kw{map}, and the two occurrences of the constant \kw{"Hydro"}. These last two are highlighted because the selected output cell was constructed by eliminating a Boolean value that was in turn constructed by the primitive \kw{==} operator, which consumed the two strings. On the basis of this interaction, the user might conjecture that the two occurrences of \kw{"Geo"} were somehow responsible for the inclusion of the third cons cell in the output; they can confirm this by making the green selection on the right. (Highlighting \kw{==} too would clearly be helpful here; we discuss this possibility in \secref{conclusion}.)

\begin{figure}
   \begin{subfigure}{0.48\textwidth}
      \small
      \lstinputlisting[language=Fluid,escapeinside={(*@}{@*)}]{fluid/source-highlighting-1.fld.mod}
   \end{subfigure}
   \hfill
   \begin{subfigure}{0.48\textwidth}
      \small
      \lstinputlisting[language=Fluid,escapeinside={(*@}{@*)}]{fluid/source-highlighting-2.fld.mod}
      \end{subfigure}
   \caption{Source selections (yellow) resulting from selecting different list cells (green)}
\label{fig:surface-language:example-1}
\end{figure}

\subsection{Forward desugaring}

We define a family of \textit{forward desugaring} functions $\desugarFwdF{t}: \Sel{\raw{s}}{A} \to \Sel{\raw{e}}{A}$ which elaborate surface terms to core terms whilst maximally preserving selection information. The full definition is \ifappendices given in \appref{surface-language} \else \IncludedWithSupplementaryMaterial \fi; \figref{surface-language:desugar} gives a representative selection of the rules. Forward desugaring follows a similar pattern to the meet-preserving forward evaluation function defined in \secref{data-dependencies:analyses:fwd}: the basic principle is for each rule to take the meet of the selection states on any parts of $s$ being consumed, and using that as the selection state for any parts of $e$ being generated at that step.

\begin{figure}
   \input{fig/surface-language/slicing/desugar-short.tex}
   \caption{Forwards and backwards desugaring (selected rules only)}
   \label{fig:surface-language:desugar}
\end{figure}

The rules for list notation map selection states $\alpha$ on the opening and closing brackets $\annot{\kw{[}}{\alpha}$ and $\annot{\kw{]}}{\alpha}$ to the first cons and the nil of the resulting list, and those on intervening delimiters $\annot{\comma}{\alpha}$ to the corresponding cons. List comprehensions $\annListComp{s}{\vec{q}}{\alpha}$ have a rule for each possible qualifier at the head of $\vec{q}$, plus a rule for the case when $\vec{q}$ is empty. The general pattern is to push the selection state on the comprehension itself through recursively, so it ends up on all core terms generated during its elaboration, such as the \kw{false} branch in the \ruleName{$\desugarFwdR$-list-comp-guard} case and the singleton list constructed in the \ruleName{$\desugarFwdR$-list-comp-guard} case. The \ruleName{$\desugarFwdR$-list-comp-gen} case uses two auxiliary judgments (not shown): $p, e \clauseFwdR \sigma$ turns the pattern $p$ and core term $e$ into an eliminator $\sigma$ with a single branch, and $\totaliseFwd{\sigma}{\alpha}{p}{\sigma'}$ extends $\sigma$ with additional branches that return the empty list for any value which does not match $p$, so it is an appropriate argument to \kw{concatMap}. The $\clauseFwdR$ is also used in the \ruleName{$\desugarFwdR$-list-comp-decl} case.

\subsection{Backward desugaring}

To desugar backwards, we define a family of \textit{backward desugaring} functions $\desugarBwdR{\raw{t}}: \Sel{\raw{e}}{A} \to \Sel{\raw{t}}{A}$ for any $\raw{t} \desugarR \raw{e}$ which uses the original raw surface term $\raw{t}$ to guide the analysis backwards. (The role of $\raw{t}$ in disambiguating the backwards rules should be clear by considering that $e$ will typically match multiple rules but only one for a given $\raw{t}$.) \figref{surface-language:desugar} gives some representative rules; the full definition is {\ifappendices given in \appref{surface-language} \else \IncludedWithSupplementaryMaterial.\fi} When reversing a desugaring step, the guiding principle is to take the join of the selection states of any core syntax constructed at this step, and use that as the selection state on the original surface syntax, turning demand on the core term into (minimal) demand on the surface term. Thus the effect of the list comprehension rules and auxiliary judgements is to set the demand on the comprehension itself to be the join of the demand of all the syntax generated during the elaboration of the comprehension. In the \ruleName{$\desugarBwdR{}$-list-comp-gen} case, the $\totaliseFwdR{p}$ used to elaborate a singleton eliminator $\sigma$ into a total one has backwards version $\totaliseBwdR{p}$ which returns the join $\beta$ of the demands on the empty lists synthesised during desugaring.

\subsection{Round-tripping properties}

It is easy to verify that $\desugarFwdF{t}$ and $\desugarBwdF{t}$ are monotonic. Moreover they form an adjoint pair.

\begin{theorem}[Galois connection for desugaring]
  \label{thm:surface-language:desugar:gc}
     Suppose $t \desugarFwdR e$. Then ${\desugarGC{t}} \eqdef (\desugarBwdF{t}, \desugarFwdF{t}): \Sel{\raw{e}}{A} \to \Sel{\raw{s}}{A}$ is a Galois connection.
\end{theorem}

\begin{proof}
   \ifappendices See \appref{proofs-surface:desugar:gc}. \else \ProofInSupplementaryMaterial \fi
\end{proof}

\todo{Concluding remarks. Want to support backwards desugaring at an arbitrary step in the computation; may require a more sophisticated approach to desugaring that interleaves it with execution. Also need a ``resugaring'' for values, compatible with the desugaring.}
