\newpage
\section{Extending to a realistic surface language}
\label{sec:surface-language}

Up until now we have primarily considered how to track dependencies between input and output values, however, our approach also allows us to inspect selections on terms themselves to determine which fragments of our program are involved in the construction of a value. The ability to do this is not restricted to programs written using the core calculus given in \secref{core-language} -- one may want to observe how data dependencies interact with more sophisticated language constructs, such as list comprehensions and piecewise definitions.

To achieve this, it is unnecessary to augment our core language to accommodate for every new syntactic form and their forward and backward dependency semantics -- we can instead create a surface language on top of our core language. The translation between our surface and core language then gives rise to another Galois connection. In the \textit{forward} direction, we desugar surface terms in their equivalent core representation whilst preserving their selection information. Conversely, in the \textit{backward} direction we reconstruct the original surface term from the core term whilst translating the selection information backward. The Galois connection for desugaring then composes with the Galois connection for dependency analysis in \secref{data-dependencies:analyses}, allowing our approach for data linking to easily extend to tracking dependencies between outputs and programs written in the surface language. In this section, we demonstrate how this can be achieved for a small program (\figref{surface-language:example-1}) written in our example surface language.

\input{fig/surface-language/syntax}

\subsection{Surface language syntax}

Consider the program selection in \figref{surface-language:example-1}; the program uses list comprehensions to iterate through a list of records containing fields $\texttt{country}$ and $\texttt{output}$, and constructs a list of tuples containing countries and their total energy output. Assuming the output of this program were $\texttt{[("China", 304), ("USA", 125),}$ $\texttt{("Germany", 606)]}$, one could be interested in how selecting the string $\texttt{"China"}$ places a demand on list comprehensions and other constants that occur in the surface program as resources.

\begin{figure}[H]
\small
\begin{lstlisting}
let totalFor c rows = sum [ row.output | row $\leftarrow$ rows, row.country == c ]$_{\alpha_1}$
in  [ (c , totalFor c data)$_{\beta_1}$ | c $\leftarrow$ [$_{\alpha_3}$"China"$_{\beta_2}$ ,$_{\alpha_4}$ "USA"$_{\beta_3}$ ,$_{\alpha_5}$ "Germany"$_{\beta_4}$ ]$_{\alpha_6}$ ]$_{\alpha_2}$
\end{lstlisting}
\caption{List comprehension example: Surface language}
\label{fig:surface-language:example-1}
\end{figure}

\noindent
The full surface language syntax used to write this program (and others in the paper) is presented in \figref{surface-language:syntax} for completeness, however, here we focus primarily on list comprehensions and list notation. Surface terms are denoted by $s, t$; in particular, lists can now be written in the style $\kw{[} s \comma \ldots \comma s' \kw{]}$ using the term $\annList{s}{r}{\alpha}$, where $r$ either recursively defines the rest of the list, $\annListNext{s}{r}{\alpha}$, or is the end of the list, $\annListEnd{\alpha}$. List comprehensions, $\annListComp{s}{\vec{q}}{\alpha}$, then consist of a body $s$ which is constructed in reference to the environment introduced by a sequence of ``qualifiers'' $\vec{q}$. There are three variants of qualifiers: \textit{guards}, $\qualGuard{s}$, which enforce a Boolean condition $s$ to be true, \textit{generators}, $\qualGenerator{p}{s}$, which iterate through each of the elements in a list $s$ and binds them to a pattern $p$, and \textit{declarations}, $\qualDeclaration{p}{s}$, which bind an arbitrary term $s$ to $p$. We will only consider the first two forms for the purposes of \figref{surface-language:example-1}. \todo{Is this line necessary? :} It can be noted that the terms for lists and list comprehensions have selections because they correspond to selectable values i.e. $\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$.

\subsection{Forward desugaring}

\figref{desugar-fwd-short} defines a family of \textit{forward desugaring} functions $\desugarFwdR$ of type $\Below{s} \to \Below{e}$. This specifies how to desugar a surface term $s$ into its equivalent core form $e$ whilst correctly retaining selections made on $s$; the latter is done by taking the meet \todo{(we never actually use the meet operation in this section, should this be omitted?)} of all selections on resources in $s$ we consume, and propagating this onto the selections of all syntax generated by its desugaring.

\input{fig/surface-language/slicing/desugar-fwd-short.tex}

\noindent
The rules for nil $\annNil{\alpha}$ and other constants simply preserve their selected form. For cons $\annCons{s}{s'}{\alpha}$ and pairs $\annPair{s}{s'}{\alpha}$, we recursively desugar $s$ and $s'$ but preserve their selected constructors. Non-empty lists $\annList{s}{r}{\alpha}$ are similar, but we also translate the sugared list constructors $\kw{[}_\alpha$, $\kw{,}_{\alpha}$, and $\kw{]}_{\alpha}$, to their core representations $\kw{(:)}_{\alpha}$ or $\annNil{\alpha}$. List comprehensions, $\annListComp{s}{\vec{q}}{\alpha}$, are slightly more involved; each of the rules accounts for a different possible qualifier at the head of the sequence $\vec{q}$.

\todo{Note: forward desugaring is described in an operational style, and although it is presented more intuitively than before, it differs from the style used to describe backward desugaring.} If the first qualifier in a list comprehension is a generator $\qualGenerator{p}{s'}$, we elaborate $\annListComp{s}{\qualGenerator{p}{s'} \concat \vec{q}}{\alpha}$ such that for each element in the generator list $s'$, if it matches $p$ then we process the ``rest'' of the list comprehension, otherwise the empty list is returned. We achieve this by first constructing an eliminator to map over $s'$. Let the rest of the list comprehension $\annListComp{s}{\vec{q}}{\alpha}$ desugar to $e$; the operation $p, e \clauseFwdR \sigma$ then constructs a singleton eliminator $\sigma$ where matching against $p$ returns $e$. For each missing case in $\sigma$, the \textit{totalise} operation $\totaliseFwd{\sigma}{\alpha}{p}{\sigma'}$ inserts a synthesised branch returning $\annNil{\alpha}$ with the selection $\alpha$ of the original list comprehension, giving us a \textit{total} eliminator $\sigma'$. The final desugared form is the application $\funConcatMap \; \exLambda{\sigma'} e'$, where $\funConcatMap$ maps $\exLambda{\sigma'}$ over the generator list $e'$ to produce a list of lists and then flattens it.

A similar idea holds for when the first qualifier in a list comprehension is a guard, $\qualGuard{s'}$. Let $s'$ desugar into the Boolean $e'$. We elaborate $\annListComp{s}{\qualGuard{s'} \concat \vec{q}}{\alpha}$ into a Boolean eliminator such that if $e'$ holds, then the desugaring of the rest of the list comprehension $\annListComp{s}{\vec{q}}{\alpha}$ is returned, otherwise the empty list $\annNil{\alpha}$ is returned where its selection $\alpha$ is that of the original list comprehension. The final desugared form is the application of this eliminator to $e'$.

If the sequence of qualifiers in the list comprehension is empty, i.e. $\annListComp{s}{\seqEmpty}{\alpha}$, then we simply desugar its body $s$ into $e$ and cons it to an empty list. This results in $\annCons{e}{\annNil{\alpha}}{\alpha}$ where the original selection $\alpha$ is propagated onto both the cons constructor and empty list.

\begin{figure}[H]
\small
\begin{lstlisting}
let totalFor c rows =
      sum (concatMap $\exLambda{\{\elimVar{\kw{row}}{  \exLambda{\elimBool{ \kw{(} \annCons{\kw{row.output}}{\annNil{\alpha_1}}{\alpha_1} \kw{)} }{\annNil{\alpha_1}}} \; \kw{(row.country == c)} }\}}$ rows)
in  concatMap $\exLambda{\{\elimVar{\kw{c}}{ \kw{(} \annCons{\kw{(c, totalFor c data)}_{\beta_1}}{\annNil{\alpha_2}}{\alpha_2} \kw{)}  }\}}$ ("China"$_{\beta_2}$:$_{\alpha_3}$ "USA"$_{\beta_3}$:$_{\alpha_4}$ "Germany"$_{\beta_4}$:$_{\alpha_5}$[]$_{\alpha_6}$)
\end{lstlisting}
\caption{List comprehension example: Surface language forward desugared}
\label{fig:surface-language:example-4}
\end{figure}

\noindent
Desugaring the surface language program in \figref{surface-language:example-1} with these rules yields the core program in \figref{surface-language:example-4}, where the selections $\alpha_i$ on the original list comprehensions and sugared list notation have been propagated and the selections $\beta_i$ on constants and the pair constructor have been preserved.

\subsection{Backward desugaring}

In order to desugar backwards, we need something that plays the role of a trace (as in the backward evaluation analysis in \secref{data-dependencies:analyses:bwd}). For desugaring, it is sufficient to use the original program and allow the trace $t$ to range over raw surface terms $s$. \figref{desugar-bwd-short} gives a family of \textit{backward desugaring} functions $\desugarBwdR{t}$ of type $\Below{e} \to \Below{s}$, where $\desugarBwdR{t}$ is defined by recursion over $t$. These specify how core terms $e \in \Below{e}$ backward desugar over a trace $t$ to recover their surface representation $s \in \Below{s}$, where $t$ corresponds to the unselected form of $s$. During this, the join operation is used to combine selection information; this expresses that if any of the generated terms that $s$ desugared into are needed as resources, then $s$ itself is also needed.

\input{fig/surface-language/slicing/desugar-bwd-short.tex}

The rule for nil $\annNil{\alpha}$ and other constants simply preserve the selection state. For non-empty lists, $\annCons{e}{e'}{\alpha}$, we recursively backward desugar the head and tail of the list and use its trace, $\exCons{t}{t'}$ or $\exList{t}{r}$, to determine the original list constructor used in its surface representation.

\todo{In this subsection, we need to check that the explanation doesn't make too many jumps by omitting steps in the backward desugaring process. } If the trace is of the form $\exListComp{t'}{\qualGenerator{p}{t} \concat \vec{q}}$, then the core term we backward desugar is necessarily of the form $\exApp{\exApp{\funConcatMap}{\exLambda{\sigma}}}{e}$. The syntactic forms that we generated during desugaring consist of the rest of the list comprehension $\annListComp{s'}{\vec{q}'}{\beta'}$ and the branches of $\sigma$ with body $\annNil{\beta}$ which were synthesized by \textit{totalise}. We use this information to reconstruct the surface term $\annListComp{s'}{\qualGenerator{p}{s} \concat \vec{q}'}{\beta \join \beta'}$, combining the demand $\beta$ on the synthesized branches with the demand $\beta'$ on the list comprehension.

When the trace has form $\exListComp{t}{\qualGuard{t'} \concat \vec{q}}$, the core term is necessarily $\exApp{\exLambda{\elimBool{e}{\annNil{\alpha}}}}{e'}$. The syntax generated during desugaring consists of the rest of the list comprehension $\annListComp{s'}{\vec{q}'}{\beta}$ found in the $\exTrue$ branch, and $\annNil{\alpha}$ found in the $\exFalse$ branch. We recover the final surface term $\annListComp{s}{\qualGuard{s'} \concat \vec{q}'}{\alpha \join \beta}$, combining the demand placed on each branch of the Boolean eliminator.

Lastly, the trace $\exListComp{t}{\seqEmpty}$ must necessarily correspond to the core term $\annCons{e}{\annNil{\alpha}}{\alpha'}$. The two forms generated by desugaring were  $\kw{:}_{\alpha'}$ and $\annNil{\alpha}$, so the recovered surface term $\annListComp{s}{\seqEmpty}{\alpha \join \alpha'}$ merges the demand placed on the cons and nil constructors.

\todo{Where do we place this in the appendix?}
\begin{definition}[Disjoint join of partial continuations]
   Define $\disjjoin$ to be the smallest partial symmetric function satisfying the equations in \figref{surface-language:disjoin-join-elim}.
\end{definition}

\todo{Finish section on discussion of this theorem?}
\begin{theorem}[Galois connection for desugaring]
  \label{thm:surface-language:desugar:gc}
     Suppose $s \desugarFwdR e$. Then $\desugarFwdF{s} \adjoint \desugarBwdF{s}$.
\end{theorem}