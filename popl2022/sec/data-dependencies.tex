\section{A bidirectional dynamic dependency analysis}
\label{sec:data-dependencies}

We now extend the core language described in \secref{core-language} with a bidirectional mechanism for tracking data dependencies. The first thing to establish is a way of selecting parts of the program of interest. Consider the \kw{data} field of the bar chart computed in \figref{introduction:data-linking}, which contains a list of records; the record corresponding to China is $\exRec{\bind{\kw{x}}{\kw{"China"}} \concat \bind{\kw{y}}{\kw{295.3}}}$. In the example, we selected the value of the field $\kw{y}$ in order to see the corresponding selection on the input.

Our approach to representing selections is shown in \figref{core-syntax-selection}. The basic idea is to parameterise the type $\Set{Val}$ of values by an abstract type $\Ann{A}$ of \emph{selection states} $\alpha$. \todo{I would say $\Ann{A}$ \emph{is} a bounded latice, rather than an abstract type. I think that's enough to explain this is a parameter that can be various specific things - and it may be a bit simpler?} We add selection states to Booleans, integers, records and lists; for our present purposes, we are only interested in dependencies between first-order data, so closures are not (directly) selectable, although they have selectable parts. We parameterise the type $\Set{Term}$ of terms in the same way, but only add selection states to the term constructors corresponding to selectable values, allowing us to trace data dependencies back to expressions that appear in the source code. We return to this in \secref{surface-language}.

\input{fig/core-language/slicing/syntax}

The abstract type $\Ann{A}$ of selection states is required to be a (bounded) lattice: it must have top and bottom elements $\top$ and $\bot$ representing fully selected/unselected, plus meet and join operations $\meet$ and $\join$ for combining selection information, with $\top$ and $\bot$ as their respective units. The Boolean lattice $\Bool \eqdef \Lattice{\Bool}{\TT}{\FF}{\wedge}{\vee}$ can represent the selection above as $\annRec{\bind{\kw{x}}{\annStr{\kw{"China"}}{\FF}} \concat \bind{\kw{y}}{\annInt{\kw{295.3}}{\TT}}}{\FF}$, indicating that the number $\exInt{\kw{295.3}}$ is selected, but neither the string $\exStr{\kw{"China"}}$, nor the record itself is selected. More interesting lattices such vectors of Booleans can be used to represent multiple selections simultaneously.

\begin{figure}
   \input{fig/core-language/slicing/leq-value}
   \caption{Partial order on values}
   \label{fig:data-dependencies:leq}
\end{figure}

\input{sec/data-dependencies/selections}
\input{sec/data-dependencies/analyses}
