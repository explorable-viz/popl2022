\section{A bidirectional dynamic dependency analysis}
\label{sec:data-dependencies}

We now show how to extend the core language described in \secref{core-language} with a bidirectional mechanism for tracking data dependencies. The first thing to establish is a way of selecting parts of the program of interest. We represent selections using an abstract type $\textcal{A}$ of annotations and then parameterise the data type of values $\Set{Val}$ by $\textcal{A}$ so that individual values can be annotated by their selection state, as defined in \figref{core-syntax-selection}. Because we are primarily interested in tracking data dependencies between values, we only annotate values which are first-order data forms and terms which construct them. The annotation-augmented forms for values include: Booleans $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{v}}}{\alpha}$, lists $\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$, and vectors $\annVecVal{\vec{v}}{\annInt{j}{\alpha}}{\smash{\alpha'}}$. The corresponding annotated forms for terms are defined similarly.

% We also introduce holes $\hole$ as a special values that express annotating every position within a value with the bottom element of a lattice.

The selection type $\textcal{A}$ is chosen to remain abstract as there are various forms of selection information we may want to express in our language, however we do require $\textcal{A}$ to be a lattice. In other words, selections must at least have top $\top$ and bottom $\bot$ elements representing fully selected and fully unselected respectively, and a meet $\meet$ and join $\join$ operation for combining selection information using intersection and union where $\top$ and $\bot$ are their left and right units.

The most obvious notion of selection is achieved by using the Boolean lattice, $\textcal{2}$, where the top $\top$ and bottom $\bot$ elements are assigned true $\TT$ and false $\FF$, and the meet $\meet$ and $\join$ operations are conjunction $\land$ and disjunction $\lor$. However, we can also use more sophisticated lattices such as a vector of Booleans to represent multiple selections simultaneously.

\input{fig/core-language/syntax-selection}
\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

% \input{fig/core-language/slicing/join-value}
% \input{fig/core-language/slicing/join-elim}

\noindent

\subsection{Selections of a value}

We can recover the syntax of unannotated values described in \secref{sec:core-language} from annotated values by defining an erasure operation $\erase{v} : \tyFun{\ValF{\textcal{A}}}{\ValF{\Unit}}$ which erases its annotations of type $\textcal{A}$ to be the trivial one-point lattice $\Unit$. We can hence think of $|v|$ as the underlying shape of the annotated value $v$. From now on, we will use $\mathbf{u}, \mathbf{v}$ to range over \textit{unannotated} values and reserve $u, v$ for \textit{annotated} values (and similarly for terms and eliminators). This is useful for letting us consider all annotated values of a given shape:

\begin{definition}[Selections of $\mathbf{v}$ for a selection type $\textcal{A}$]
   Define $\Sel{v}{A}$ as the set of all values $v$ annotated with selection type $\textcal{A}$ that are of the shape $\textbf{v}$, i.e. $v$ erases to $\mathbf{v}$.
\end{definition}

Since the elements of $\SelF{v}$ have a fixed shape, $\SelF{v}$ is a \textit{representable} functor with a fixed shape given by $\mathbf{v}$. In particular, for any $v, v'$ in $\Sel{v}{A}$, the zip of a binary operation over $v$ and $v'$ is well-defined \cite{gibbons17}. In turn, this means that if $\textcal{A}$ is a lattice then $\Sel{v}{A}$ is also a lattice with meet and join defined by zipping the meet and join of $\textcal{A}$ over $v$ and $v'$. For example, the join of two cons values $(\annCons{u}{v}{\alpha})$ and $(\annCons{u'}{v'}{\alpha'})$ involves recursively joining over $u$ and $u'$, and $v$ and $v'$, and then also taking the join of $\alpha$ and $\alpha'$ to result in $\annCons{(u \join u')}{(v \join v')}{\alpha \join \alpha'}$. The top element of $\Sel{v}{A}$ is then the value $v$ with shape $\mathbf{v}$ which has the top element of $\textcal{A}$ at every annotation position, and conversely for the bottom element.

\newpage
\subsubsection{Hole equivalence}

% By annotating values with lattices as selection types, we can also introduce the notion of \textit{holes} $\hole$ as special values that express annotating every position within a value with the bottom element of a lattice.

As lattices are partially ordered, annotations $\textcal{A}$ also induce a partial order on annotated values $\Sel{v}{A}$, where two values $v$ and $v'$ are related by $\leq$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$ (defined in \figref{leq-value-eliminator} and \figref{leq-term}). We can then enrich the set of annotated values $\Sel{v}{A}$ by introducing the distinguished element hole $\hole_{\mathbf{v}}$, which is alternative notation for the bottom element of $\Sel{v}{A}$, i.e. the value of shape $\mathbf{v}$ where all annotation positions are $\bot$. As a consequence, it follows that $\hole \join v = v$ and $v \join \hole = v$ for any $v$, and conversely that $\hole \meet v = \hole$ and $v \meet \hole = \hole$.

The $\leq$ relation with holes induces an equivalence relation, $\eq$, which we call \textit{hole equivalence}:

% The equivalence relation induced by this partial order means that the bottom element of

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

This equivalence relation means that value selections can have multiple representations, and captures the idea that any substructures of a value $v$ that are annotated completely with $\bot$ can equivalently be replaced by a hole. For example, the following values are hole equivalent: $(\annCons{\hole_{\kw{\textbf{true}}}}{\hole_{\kw{\textbf{[]}}}}{\top})$, $(\annCons{\exTrue_{\bot}}{\hole_{\kw{\textbf{[]}}}}{\top})$, $(\annCons{\hole_{\kw{\textbf{true}}}}{\exNil_{\bot}}{\top})$, and $(\annCons{\exTrue_{\bot}}{\hole_{\exNil_{\bot}}}{\top})$. The notion of holes is important for performance purposes, as we often need an efficient representation of environments where the majority of bindings are unselected.

%We can enrich this partial order by introducing hole $\hole$ into the set of annotated values $\Sel{v}{A}$, where holes let us represent any value in a fully unselected state (every annotation position within it is $\bot$).

% We can then introduce the notion of hole-equivalence, which captures the idea that we can refine a hole using a provided value structure $\mathbf{v}$ to produce an equivalent value $v$ where all annotation positions are $\bot$:



% when joining or meeting or zipping, the structures of two values have to be equal, but we can relax the notion of equivalence to think of holes to be structurally equal to any value.

% include examples of hole equivalence, e.g. the following are all equivalent up to `dot equals', for example hole is equivalent to cons of a hole with false and a hole, which is equivalent to cons of True with false on it and hole. Refining a hole with substructure produces an equivalent value as long as any annotation positions in the substructure are false.

% Given that lattices have the property of being partially ordered, annotations also induce a partial order on the annotated syntactic forms, where two values $v$ and $v'$ are related by $v \leq v$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$. This relation is defined for values and eliminators in \figref{leq-value-eliminator} and terms in \figref{leq-term}, and is later necessary for lifting the lattice properties of selection types $\mathcal{A}$ to the type of syntax annotated with $\mathcal{A}$.

% Every partial order has an equivalence relation that it induces and that relation which we write as 'dot equals' is going to make \hole equivalent to any value that only has false annotations. Whenever hole occurs in a value position, we always know what shape the value is expected to have (because we always run the analysis in the context of a known shape). This means we can use the equivalent non-hole form to know what to do in that situation.

% In the figure for forward and backward dependency, we always have the first rule which uses hole equivalence. For fwd, it says that if \rho, e are hole-equivalent to \rho', e', then the forward analyses are equivalent. For bwd, if v is hole equivalent to u, then the backward analysis for v is the same as the backward analysis for u. If we have some kind of value that is either a hole or has some holes within it, and it is insufficiently specified for any of the other equations for hole, then we know that we can specialize it into a structure that has the other equation plus hole by explicitly fleshing it out.

\subsection{Forward and backward Galois dependency}
\label{sec:core-language:fwd-bwd}

\todo{Introduce this section}. \figref{eval:bwd} gives the semantics for forward and backward evaluation of the annotated core language.

\subsubsection{Evaluation}

Forward evaluation, $\evalFwdF{T} :: \Below{ \tyProd{(\boldsymbol{\rho},\mathbf{e})}{\mathcal{A}} } \to \Below{\mathbf{v}}$, describes how we evaluate a term $e$ under environment $\rho$ to a value $v$, whilst propagating the annotation information of the outer term which contains $e$. When working in the forwards direction, we want to express that a value is only selected if all the terms involved in its construction are selected, hence we use the meet $\meet$ operation to combine selection states.

Evaluating a variable $x$ is equivalent to looking it up in the environment $\rho$, where $\envLookupFwdF{}$ is defined in \figref{core-language:slicing:eval-aux}. Anonymous functions $\exLambda{\sigma}$ simply evaluate to closures, which are unannotated. We begin to see how the $\meet$ operation is used when evaluating an integer $n_{\alpha'}$ with an outer annotation $\alpha$ - this returns $\annot{n}{\alpha \meet \alpha'}$, expressing that the value $n$ is selected if both the term $n$ and the term containing $n$ was selected. The same logic applies to empty lists $\annot{\exNil}{\alpha'}$. % For records $\exRec{\vec{\bind{x}{e}}}_{\alpha}$ with annotation $\alpha'$, we evaluate each term $e_i$ in the record to a value $v_i$, and then return $\vec{\bind{x}{e}}$ annotated by $\alpha \meet \alpha'$. Project a field $x$ out of a record $e$ will retrieve the term in $e$ with position $i$ corresponding to $x$, and evaluate it to $v_i$.

For the cons rule, $\exPair{(\rho,\annCons{e_1}{e_2}{\alpha'})}{\alpha}$, we forward analyse $e_1$ and $e_2$ to get annotated values $v_1$ and $v_2$, and then construct the value $\annCons{v_1}{v_2}{\alpha \meet \alpha'}$ where the cons constructor is only selected if both $\exCons{e_1}{e_2}$ and the outer term containing it are selected.

% Give the intuition that what we do with annotation propagation is specifying how we consume resources in the input in order to construct things in the output.

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\input{fig/core-language/slicing/eval}
\input{fig/core-language/slicing/eval-aux}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}

\subsubsection{Pattern-matching}

\input{fig/core-language/slicing/match}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}
