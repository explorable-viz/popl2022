\section{A bidirectional dynamic dependency analysis}
\label{sec:data-dependencies}

We now show how to extend the core language described in \secref{core-language} with a bidirectional mechanism for tracking data dependencies. The first thing to establish is a way of selecting parts of the program of interest. We represent selections using an abstract type $\textcal{A}$ of annotations and then parameterise the data type of values $\Set{Val}$ by $\textcal{A}$ so that individual values can be annotated by their selection state, as defined in \figref{core-syntax-selection}. Because we are primarily interested in tracking data dependencies between values, we only annotate values which are first-order data forms and terms which construct them. The annotation-augmented forms for values include: Booleans $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{v}}}{\alpha}$, lists $\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$, and vectors $\annVecVal{\vec{v}}{\annInt{j}{\alpha}}{\smash{\alpha'}}$. The corresponding annotated forms for terms are defined similarly.

% We also introduce holes $\hole$ as a special values that express annotating every position within a value with the bottom element of a lattice.

The selection type $\textcal{A}$ is chosen to remain abstract as there are various forms of selection information we may want to express in our language, however we do require $\textcal{A}$ to be a lattice. In other words, selections must at least have top $\top$ and bottom $\bot$ elements representing fully selected and fully unselected respectively, and a meet $\meet$ and join $\join$ operation for combining selection information using intersection and union where $\top$ and $\bot$ are their left and right units.

The most obvious notion of selection is achieved by using the Boolean lattice, $\textcal{2}$, where the top $\top$ and bottom $\bot$ elements are assigned true $\TT$ and false $\FF$, and the meet $\meet$ and $\join$ operations are conjunction $\land$ and disjunction $\lor$. However, we can also use more sophisticated lattices such as a vector of Booleans to represent multiple selections simultaneously.

\input{fig/core-language/syntax-selection}
\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

% \input{fig/core-language/slicing/join-value}
% \input{fig/core-language/slicing/join-elim}

\noindent

\input{sec/data-dependencies/selections}
\input{sec/data-dependencies/analysis}
