\section{A bidirectional dynamic dependency analysis}
\label{sec:data-dependencies}

We now extend the core language described in \secref{core-language} with a bidirectional mechanism for tracking data dependencies. The first thing to establish is a way of selecting parts of the program of interest. Consider the \kw{data} field of the bar chart computed in \figref{introduction:data-linking}, which contains a list of records; the record corresponding to China is $\exRec{\bind{\kw{x}}{\kw{"China"}} \concat \bind{\kw{y}}{\kw{295.3}}}$. In the example, we selected the value of the field $\kw{y}$ in order to see the corresponding selection on the input.

Our approach to representing selections is shown in \figref{core-syntax-selection}. The basic idea is to parameterise the type $\Set{Val}$ of values by an abstract type $\Ann{A}$ of \emph{annotations}, indicating selection state. We add annotations $\alpha \in \Ann{A}$ to Booleans, integers, records and lists; for our present purposes, we are only interested in tracking dependencies between first-order data, so first-class primitives and closures are not annotated. We do, however, annotate the term constructors corresponding to annotated values, allowing us to trace data dependencies back to constants that appear in the source code. We return to this in \secref{surface-language}.

\input{fig/core-language/slicing/syntax}

The abstract type $\Ann{A}$ of annotations is required to be a (bounded) lattice: it must have top and bottom elements $\top$ and $\bot$ representing fully selected/unselected, plus meet and join operations $\meet$ and $\join$ for combining selection information, with $\top$ and $\bot$ as their respective units. The Boolean lattice $\Bool \eqdef \Lattice{\Bool}{\TT}{\FF}{\wedge}{\vee}$ can represent the selection above as $\annRec{\bind{\kw{x}}{\annStr{\kw{"China"}}{\FF}} \concat \bind{\kw{y}}{\annInt{\kw{295.3}}{\TT}}}{\FF}$, indicating that the number $\exInt{\kw{295.3}}$ is selected, but neither the string $\exStr{\kw{"China"}}$, nor the record itself is selected. More interesting lattices such vectors of Booleans can be used to represent multiple selections simultaneously.

\begin{figure}
   \input{fig/core-language/slicing/leq-value-elim}
   \input{fig/core-language/slicing/leq-term}
   \caption{Partial orders on values, eliminators and terms}
   \label{fig:data-dependencies:leq}
\end{figure}

\input{sec/data-dependencies/selections}
\input{sec/data-dependencies/analyses}
