\section{A bidirectional dynamic dependency analysis}
\label{sec:data-dependencies}

We now extend the core language described in \secref{core-language} with a bidirectional mechanism for tracking data dependencies. The first thing to establish is a way of selecting parts of the program of interest. Consider the \kw{data} field of the bar chart computed in \figref{introduction:data-linking}, which is bound to a list of records; one of these records is $\exRec{\bind{\kw{x}}{\kw{"China"}} \concat \bind{\kw{y}}{\kw{295.3}}}$. In the example, we want to select the value of the field $\kw{y}$ so that we can see the corresponding selection on the input.

Our approach to representing selections like these is shown in \figref{core-syntax-selection}. The basic idea is to parmaeterise the type $\Set{Val}$ values an abstract type $\textcal{A}$ of \emph{annotations}, which indicate selection state, and then add an annotation to every data constructor which specifies the selection state of any values made using that constructor. Because we are primarily interested in tracking data dependencies between values, we only annotate values which are first-order data forms and terms which construct them. The annotation-augmented forms for values include: Booleans $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{v}}}{\alpha}$, lists $\annNil{\alpha}$ and $\annCons{u}{v}{\alpha}$, and vectors $\annVecVal{\vec{v}}{\annInt{j}{\alpha}}{\smash{\alpha'}}$. The corresponding annotated forms for terms are defined similarly.

\input{fig/core-language/slicing/syntax}

The selection type $\textcal{A}$ is chosen to remain abstract as there are various forms of selection information we may want to express in our language, however we do require $\textcal{A}$ to be a lattice. In other words, selections must at least have top $\top$ and bottom $\bot$ elements representing fully selected and fully unselected respectively, and a meet $\meet$ and join $\join$ operation for combining selection information using intersection and union where $\top$ and $\bot$ are their left and right units.

The most obvious notion of selection is achieved by using the Boolean lattice, $\textcal{2}$, where the top $\top$ and bottom $\bot$ elements are assigned true $\TT$ and false $\FF$, and the meet $\meet$ and $\join$ operations are conjunction $\land$ and disjunction $\lor$. Using this, we can represent the selection of the value of the field $\kw{China}$ in the record given earlier as $\annot{\exRec{\bind{\kw{China}}{\annot{295.3}{\TT}}, \bind{\kw{USA}}{\annot{196.7}{\FF}}, \bind{\kw{Germany}}{\annot{91.8}{\FF}}}}{\FF}$. However, more sophisticated lattices can also be used such as a vector of Booleans to represent multiple selections simultaneously.

\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

% \input{fig/core-language/slicing/join-value}
% \input{fig/core-language/slicing/join-elim}

\noindent

\input{sec/data-dependencies/selections}
\input{sec/data-dependencies/analyses}
