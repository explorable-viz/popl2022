\section{A bidirectional dynamic dependency analysis}
\label{sec:data-dependencies}

We now show how to extend the core language described in \secref{core-language} with a bidirectional mechanism for tracking data dependencies. The first thing to establish is a way of selecting parts of the program of interest. We use \textit{annotations}, defined in \figref{core-syntax-selection}, to capture the notion of selections by augmenting all first-order data forms to be parameterised by an annotation type indicating their selection state.

The selection type $\mathcal{A}$ is chosen to remain abstract as there are various forms of selection information we may want to express in our language, however we do require them to be a lattice. This enforces that selection types must have a top $\top$ and bottom $\bot$ element representing selection and unselection respectively, and a meet $\meet$ and join $\join$ operation where $\top$ and $\bot$ are their left and right units. The elements of a lattice will be used to model the selection state of values, and the meet and join operations will be used to combine selection information.

Given that lattices have the property of being partially ordered, annotations also induce a partial order on the annotated syntactic forms, where two values $v$ and $v'$ are related by $v \leq v$ if each annotation in $v$ is below the annotation in the corresponding position in $v'$. This relation is defined for values and eliminators in \figref{leq-value-eliminator} and terms in \figref{leq-term}, and is later necessary for lifting the lattice properties of selection types $\mathcal{A}$ to the type of syntax annotated with $\mathcal{A}$.

When considering an appropriate choice of selection type, the most straightforward notion of selection is achieved by using the Boolean lattice where the top $\top$ and bottom $\bot$ elements are assigned true $\TT$ and false $\FF$, and the meet $\meet$ and $\join$ operations are conjunction $\land$ and disjunction $\lor$. However, we can also use more sophisticated lattices such as a vector of Booleans to represent multiple selections simultaneously.

\input{fig/core-language/syntax-selection}
\input{fig/core-language/slicing/leq-value-elim}
\input{fig/core-language/slicing/leq-term}

\begin{definition}[Hole equivalence]
   Define $\eq$ as the intersection of $\leq$ and $\geq$.
\end{definition}

\input{fig/core-language/slicing/join-value}
\input{fig/core-language/slicing/join-elim}

\noindent
As we are primarily interested in tracking data dependencies between values, we only annotate values and the expression forms which construct values, given in \figref{core-syntax-selection}. The annotation-augmented forms for values include: Booleans $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{v}}}{\alpha}$, empty lists $\annNil{\alpha}$ and cons nodes $\annCons{u}{v}{\alpha}$, and vectors $\annVecVal{\vec{v}}{\annInt{j}{\alpha}}{\smash{\alpha'}}$. We also introduce holes $\hole$ as a special values that express annotating every position within a value with the bottom element of a lattice. The corresponding annotated forms for expressions then consist of: holes $\hole$, Booleans $\annTrue{\alpha}$ and $\annFalse{\alpha}$, integers $\annInt{n}{\alpha}$, records $\annRec{\vec{\bind{x}{e}}}{\alpha}$, empty lists $\annNil{\alpha}$ and cons nodes $\annCons{e}{e'}{\alpha}$, and vectors $\annVec{e}{x}{e'}{\alpha}$.

% The most simple choice of lattice would be to set the type of annotations to be the trivial unit lattice -- this lets us recover the original unannotated syntax presented in \figref{core-language:syntax}.

\subsubsection{Properties Of Annotated Types}

From now on, we make an important distinction in the notation for \textit{annotated} values $v$ (defined in Figure \ref{fig:core-syntax-selection}) and \textit{unannotated} values $\mathbf{v}$ (defined in Figure \ref{fig:core-language:syntax}), with the same reasoning applying to terms and eliminators. The syntax for unannotated values $\mathbf{v}$ can also be understood as annotated values $v$ where its selection type is the trivial one-point lattice, $\Unit$. We hence observe that $\mathbf{v}$ can be recovered from $v$ by defining an erasure operation $\erase{v} : \tyFun{\TermF{\mathcal{A}}}{\TermF{\Unit}}$ which maps a value with selection type $\mathcal{A}$ to the same value but with annotation type $\Unit$. This is useful for letting us consider all annotated values of a given shape:

\begin{definition}[Selections of $\mathbf{v}$ for a selection type $\mathcal{A}$]
   Define $\Sel{v}{A}$ as the set of all values $v$ annotated with selection type $\mathcal{A}$ that are of the shape $\textbf{v}$, i.e. $v$ erases to $\mathbf{v}$.
\end{definition}

The data type $\SelF{v}$ is hence a representable functor with a fixed shape given by $\mathbf{v}$. This means that for any $v, v'$ in $\Sel{v}{A}$, we can zip a binary operation over $v$ and $v'$ because they have the same shape. This property allows the set $\Sel{v}{A}$ to form a lattice, where the top element is the value which has top $\top$ at every annotation position, and the bottom element has bottom $\bot$ at every position. Meet and join are then defined by lifting the meet and join operations on $\mathcal{A}$ to the type $\Sel{v}{A}$; this lets us zip over the structure of two values and combine their selection states at every position. The join operation is given for values and eliminators in \figref{join-value} and \figref{join-elim}, and the meet operation is defined conversely.

\subsection{Forward and backward Galois dependency}
\label{sec:core-language:fwd-bwd}

\todo{Introduce this section}. \figref{eval:bwd} gives the semantics for forward and backward evaluation of the annotated core language.

\subsubsection{Evaluation}

Forward evaluation, $\evalFwdF{T} :: \Below{ \tyProd{(\boldsymbol{\rho},\mathbf{e})}{\mathcal{A}} } \to \Below{\mathbf{v}}$, describes how we evaluate a term $e$ under environment $\rho$ to a value $v$, whilst propagating the annotation information of the outer term which contains $e$. When working in the forwards direction, we want to express that a value is only selected if all the terms involved in its construction are selected, hence we use the meet $\meet$ operation to combine selection states.

Evaluating a variable $x$ is equivalent to looking it up in the environment $\rho$, where $\envLookupFwdF{}$ is defined in \figref{core-language:slicing:eval-aux}. Anonymous functions $\exLambda{\sigma}$ simply evaluate to closures, which are unannotated. We begin to see how the $\meet$ operation is used when evaluating an integer $n_{\alpha'}$ with an outer annotation $\alpha$ - this returns $\annot{n}{\alpha \meet \alpha'}$, expressing that the value $n$ is selected if both the term $n$ and the term containing $n$ was selected. The same logic applies to empty lists $\annot{\exNil}{\alpha'}$. % For records $\exRec{\vec{\bind{x}{e}}}_{\alpha}$ with annotation $\alpha'$, we evaluate each term $e_i$ in the record to a value $v_i$, and then return $\vec{\bind{x}{e}}$ annotated by $\alpha \meet \alpha'$. Project a field $x$ out of a record $e$ will retrieve the term in $e$ with position $i$ corresponding to $x$, and evaluate it to $v_i$.

For the cons rule, $\exPair{(\rho,\annCons{e_1}{e_2}{\alpha'})}{\alpha}$, we forward analyse $e_1$ and $e_2$ to get annotated values $v_1$ and $v_2$, and then construct the value $\annCons{v_1}{v_2}{\alpha \meet \alpha'}$ where the cons constructor is only selected if both $\exCons{e_1}{e_2}$ and the outer term containing it are selected.

% Give the intuition that what we do with annotation propagation is specifying how we consume resources in the input in order to construct things in the output.

\paragraph{Primitive operations}

Each primitive operation $\phi: \tyInt^{i} \to \tyInt$ must for every $\vec{n}$ with $\length{\vec{n}} = i$ provide a Galois connection $(\primFwdBool{\phi}{\vec{n}}, \primBwdBool{\phi}{\vec{n}})$ between $\Bool^i$ and $\Bool$, which we lift to a Galois connection $(\primFwd{\phi}{\vec{n}}, \primBwd{\phi}{\vec{n}})$ between $\Below{\vec{n}}$ and $\Below{\phi(\vec{n})}$ by defining
\begin{definition}
\label{def:core-language:primop-gc}
\begin{salign}
   \primFwd{\phi}{\vec{n}}(\vec{\annInt{n}{\alpha}}) &= \annInt{m}{\beta}
   \text{ where }
   \primFwdBool{\phi}{\vec{n}}(\vec{\alpha}) = \beta
   \\
   \primBwd{\phi}{\vec{n}}(\annInt{m}{\beta}) &= \vec{\annInt{n}{\alpha}}
   \text{ where }
   \primBwdBool{\phi}{\vec{n}}(\beta) = \vec{\alpha}
\end{salign}
\end{definition}

\noindent where $\vec{\annInt{n}{\alpha}}$ denotes the zip of same-length sequences $\vec{n}$ and $\vec{\alpha}$ with the constructor for integer values. For any $\vec{n}$ with $\length{\vec{n}} \numlt i$, any such $\phi$ also gives rise to an isomorphism between $\Below{\vec{n}}$ and the lattice of partial applications $\Below{\exPrimOp{\phi}{\vec{n}}}$.

\input{fig/core-language/slicing/eval}
\input{fig/core-language/slicing/eval-aux}

\begin{definition}[Hole environment]
Define $\hole_{\vec{\bind{x}{v}}} = \vec{\bind{x}{\hole}}$
\end{definition}

\begin{lemma}[Least environment for $\rho$]
\label{lem:core-language:hole-env}If $\vdash \rho: \Gamma$ then $\hole_{\rho} \leq \rho$.
\end{lemma}

\begin{definition}[Forward and backward functions for environment lookup]
   Suppose $\envLookup{\rho}{x}{v}$. Then define $\envLookupFwdF{\rho,x}: \Below{\rho} \to \Below{v}$ and $\envLookupBwdF{\rho,x}: \Below{v} \to \Below{\rho}$ to be $\bind{x}{-}\envLookupR$ and $\envLookupBwdR{\rho}\bind{x}{-}$ restricted to $\Below{\rho}$ and $\Below{v}$ respectively.
\end{definition}

\begin{lemma}[Galois connection for environment]
\label{lem:core-language:env-get-put}Suppose $\envLookup{\rho}{x}{v}$.
\begin{enumerate}
   \item \label{lem:core-language:env-get-put:1} $\envLookupFwdF{\rho,x}(\envLookupBwdF{\rho,x}(v)) \geq v$.
   \item \label{lem:core-language:env-get-put:2} $\envLookupBwdF{\rho,x}(\envLookupFwdF{\rho,x}(\rho')) \leq \rho'$.
\end{enumerate}
\end{lemma}

\begin{definition}
   \label{def:core-language:closeDefs-bwd}
   Define the relation $\closeDefsBwdR$ as given in \figref{core-language:slicing:eval-aux}.
\end{definition}

\begin{definition}[Forward and backward functions for recursive bindings]
   Suppose $\rho, h \closeDefsR \rho'$. Define $\closeDefsFwdF{\rho,h}: \Below{(\rho, h)} \to \Below{\rho'}$ and $\closeDefsBwdF{\rho,h}: \Below{\rho'} \to \Below{(\rho, h)}$ to be $\closeDefsR$ and $\closeDefsBwdR$ restricted to $\Below{(\rho, h)}$ and $\Below{\rho'}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for recursive bindings]
\label{thm:core-language:closeDefs:gc}
   Suppose $\rho, h \closeDefsR \rho'$.  Then $\closeDefsFwdF{\rho,h} \adjoint \closeDefsBwdF{\rho,h}$.
\end{theorem}

\begin{definition}[Forward and backward functions for evaluation]
   Suppose $T: \rho, e \evalR v$. Define $\evalFwdF{T}: \Below{(\rho, e, \TT)} \to \Below{v}$ and $\evalBwdF{T}: \Below{v} \to \Below{(\rho, e, \TT)}$ to be $\evalFwdR{T}$ and $\evalBwdR{T}$ restricted to $\Below{(\rho, e, \TT)}$ and $\Below{v}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for evaluation]
\label{thm:core-language:eval:gc}
   Suppose $T: \rho, e \evalFwdS v$.  Then $\evalFwdF{T} \adjoint \evalBwdF{T}$.
\end{theorem}

\subsubsection{Pattern-matching}

\input{fig/core-language/slicing/match}

\begin{lemma}[Determinism of pattern-matching]
   Suppose $v, \sigma \matchFwdR{w} \rho, \kappa$ and $v', \sigma' \matchFwdR{w} \rho', \kappa'$. If $(v, \sigma) \eq (v', \sigma)$ then $(\rho, \kappa) \eq (\rho', \kappa')$.
\end{lemma}

\begin{definition}[Forward and backward functions for pattern-matching]
   Suppose $w: v, \sigma \matchR \rho, \kappa$. Define $\matchFwdF{w}: \Below{(v,\sigma,\TT)} \to \Below{(\rho,\kappa)}$ and $\matchBwdF{w}: \Below{(\rho,\kappa)} \to \Below{(v,\sigma,\TT)}$ to be $\matchFwdR{w}$ and $\matchBwdR{w}$ domain-restricted to $\Below{(v,\sigma,\TT)}$ and $\Below{(\rho,\kappa)}$ respectively.
\end{definition}

\begin{theorem}[Galois connection for pattern-matching]
\label{thm:core-language:match:gc}
   Suppose $w: v, \sigma \matchFwdS \rho, \kappa$.  Then $\matchFwdF{w} \adjoint \matchBwdF{w}$.
\end{theorem}
