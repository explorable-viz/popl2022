\let\oldbot\bot
\renewcommand{\bot}{\del{\oldbot}}

\newcommand\grayuline{\bgroup\markoverwith{\textcolor{gray}{\rule[-0.9ex]{2pt}{0.4pt}}}\ULon}
% \newcommand*{\del}[1]{\grayuline{\textcolor{gray}{\smash{#1}}}}
\newcommand*{\del}[1]{\textcolor{red}{#1}}

\renewcommand*{\ldots}{...} % \ldots sucks with acmart
\renewcommand*{\ruleName}[1]{\textcolor{gray}{\textnormal{\textsf{#1}}}}

% Section symbol.
\renewcommand*{\secref}{\Secref}
\renewcommand*{\secrefTwo}{\SecrefTwo}

% Use this in place of \mathsf.
\newcommand*{\mathSf}[1]{\textup{\textsf{#1}}}
\newcommand*{\Set}[1]{\mathSf{#1}}

\newcommand*{\Pow}[1]{\MnSymbolpowerset({#1})}
\newcommand*{\id}{\textsf{id}}
\newcommand*{\adjoint}{\dashv}
\newcommand*{\inj}{\hookrightarrow}

% Vectors.
\newcommand*{\eqAt}[1]{\mathrel{\smash{=_{#1}}}}
\newcommand*{\override}{\reloverrideleft}
\newcommand*{\seqEmpty}{\varepsilon}

% Misc.
\newcommand*{\metaunit}{\Mnast}
\newcommand*{\envExtendTwo}[2]{{#1}[#2]}
\newcommand*{\Dagger}[1]{\smash{#1^\dagger}}
\newcommand*{\DDagger}[1]{\smash{#1^\ddagger}}
\newcommand*{\fmapF}{\textsf{map}}
\newcommand*{\fmapTwoF}{\fmapF}
\newcommand*{\fmapPartial}[1]{\fmapF\,{#1}}
\newcommand*{\fmap}[2]{\fmapPartial{#1}\,{#2}}
\newcommand*{\fmapTwo}[3]{\fmapPartial{#1}\:{#2}\:{#3}}
\newcommand*{\fmapTwoPartial}[2]{\textsf{map}\:{#1}\:{#2}}
\newcommand*{\closeDefs}{\mathrel{\smalltriangleright}}
\newcommand*{\uncloseDefs}{\mathrel{\smalltriangleleft}}

% Misc. syntax.
\newcommand*{\asMap}[1]{\underline{#1}}
\newcommand*{\trace}[2]{\textcolor{gray}{#1}\mathrel{\textcolor{gray}{::}}{#2}}

% Relations.
\newcommand*{\numLabel}[1]{\textcolor{blue}{\mathSf{#1}}}

% Primitives.
\newcommand*{\primOp}{\oplus}

% Annotations.
\newcommand{\annot}[2]{#1_{#2}}

% Expressions.
\newcommand*{\exAdd}[2]{{#1} + {#2}}
\newcommand*{\exApp}[2]{{#1}\,{#2}}
\newcommand*{\exBot}{\bot}
\newcommand*{\exBranch}[2]{{#1}.{#2}}
\newcommand*{\exCons}[2]{\kw{Cons}(#1,#2)}
\newcommand*{\exConst}[1]{#1}
\newcommand*{\exConstr}[2]{#1(#2)}
\newcommand*{\exClosure}[2]{(#1,#2)}
\newcommand*{\exClosureNew}[3]{(#1,#2,#3)}
\newcommand*{\exClosureRec}[3]{(#1,\exRec{#2}{#3})}
\newcommand*{\exDefs}[2]{{#1}\;\kw{in}\;{#2}}
\newcommand*{\exFalse}{\kw{false}}
\newcommand*{\exFst}[1]{\kw{fst}\;#1}
\newcommand*{\exFun}[1]{\uplambda{#1}}
\newcommand*{\exInl}[1]{\kw{inl}\;{#1}}
\newcommand*{\exInr}[1]{\kw{inr}\;{#1}}
\newcommand*{\exInt}[1]{#1}
\newcommand*{\exLet}[3]{\kw{let}\;{#1}={#2}\;\kw{in}\;{#3}}
\newcommand*{\exLetDef}[2]{\kw{let}\;{#1}={#2}}
\newcommand*{\exLetrec}[2]{\kw{letrec}\;{#1}\;\kw{in}\;{#2}}
\newcommand*{\exLetrecDef}[1]{\kw{letrec}\;{#1}}
\newcommand*{\exLambda}[2]{\uplambda{#1}.{#2}}
\newcommand*{\exMatch}[2]{\kw{match}~{#1}~\kw{as}\;{#2}}
\newcommand*{\exNat}[1]{#1}
\newcommand*{\exNil}{\kw{Nil}}
\newcommand*{\exOp}[2]{{#1}\primOp{#2}}
\newcommand*{\exPair}[2]{\langle#1,#2\rangle}
\newcommand*{\exPrimApp}[3]{{#1} #2 {#3}}
\newcommand*{\exPrimDef}[1]{\kw{primitive}\;{#1}}
\newcommand*{\exPrimOp}{\primOp}
\newcommand*{\exRec}[2]{\kw{fun}\,{#1}{#2}}
\newcommand*{\exRoll}[1]{\kw{roll}\;{#1}}
\newcommand*{\exSnd}[1]{\kw{snd}\;#1}
\newcommand*{\exTrue}{\kw{true}}
\newcommand*{\exUnit}{\langle\rangle}
\newcommand*{\exUnroll}[1]{\kw{unroll}\;{#1}}
\newcommand*{\exVar}[1]{#1}
\newcommand*{\exThunkVar}[2]{{#1}: {#2}}
\newcommand*{\exTop}{\top}

\newcommand*{\branchCons}[3]{\exCons{#1}{#2}\mapsto{#3}}
\newcommand*{\branchConsNew}[1]{\kw{Cons}\;{#1}}
\newcommand*{\branchNil}[1]{\exNil\mapsto{#1}}

% Tries.
\newcommand*{\elimBool}[2]{\{\exTrue \mapsto {#1}, \exFalse \mapsto {#2}\}}
\newcommand*{\elimConstr}[1]{#1}
\newcommand*{\elimEmpty}{\bot}
\newcommand*{\elimFun}[1]{\elimFunNoRHS \mapsto {#1}}
\newcommand*{\elimFunNoRHS}{\uplambda}
\newcommand*{\elimGround}[2]{\elimGroundNoRHS{#1} \mapsto {#2}}
\newcommand*{\elimGroundNoRHS}[1]{\tyGround{#1}}
\newcommand*{\elimList}[2]{\{{#1},{#2}\}}
\newcommand*{\elimNarySum}[1]{\{#1\}}
\newcommand*{\elimPair}[3]{\exPair{#1}{#2}\mapsto{#3}}
\newcommand*{\elimSingleton}[2]{#1[#2]}
\newcommand*{\elimSum}[2]{[\exInl{#1},\exInr{#2}]}
\newcommand*{\elimSumL}[1]{[\exInl{#1}]}
\newcommand*{\elimSumR}[1]{[\exInr{#1}]}
\newcommand*{\elimProd}[1]{{\langle#1\rangle}}
\newcommand*{\elimRoll}[1]{\kw{roll}\;{#1}}
\newcommand*{\elimUnit}[1]{\exUnit \mapsto {#1}}
\newcommand*{\elimUnitNoRHS}{\exUnit}
\newcommand*{\elimVar}[2]{\elimVarNoRHS{#1} \mapsto {#2}}
\newcommand*{\elimVarNoRHS}[1]{#1}

\renewcommand*{\lowlight}[1]{\textcolor{gray}{#1}}

% Matches.
%\newcommand*{\matchedConstr}[1]{\elimConstr{#1}}
\newcommand*{\matchCons}[3]{\matchPlug{\exCons{#1}{#2}\mapsto}{#3}}
\newcommand*{\matchConsLow}[3]{\matchPlugLow{\exCons{#1}{#2}\mapsto}{#3}}
\newcommand*{\matchConsNew}[1]{\matchPlug{\kw{Cons}\;}{#1}}
\newcommand*{\matchConsNewLow}[1]{\matchPlugLow{\kw{Cons}\;}{#1}}
\newcommand*{\matchFalse}[1]{\matchPlug{\exFalse\mapsto}{#1}}
\newcommand*{\matchFalseLow}[1]{\matchPlugLow{\exFalse\mapsto}{#1}}
\newcommand*{\matchFalseNew}{\exFalse}
\newcommand*{\matchHole}[1]{[#1]}
\newcommand*{\matchInj}[1]{#1}
\newcommand*{\matchNil}[1]{\matchPlug{\exNil\mapsto}{#1}}
\newcommand*{\matchNilLow}[1]{\matchPlugLow{\exNil\mapsto}{#1}}
\newcommand*{\matchPair}[3]{\matchPlug{\exPair{#1}{#2}\mapsto}{#3}}
\newcommand*{\matchPairLow}[3]{\matchPlugLow{\exPair{#1}{#2}\mapsto}{#3}}
\newcommand*{\matchPairNew}[2]{\exPair{#1}{#2}}
\newcommand*{\matchPlug}[2]{#1[#2]}
\newcommand*{\matchPlugLow}[2]{\lowlight{#1[}#2\lowlight{]}}
\newcommand*{\matchProd}[2]{\matchPlug{#1}{#2}}
\newcommand*{\matchProdLow}[3]{\matchPlugLow{#1}{\matchPlugLow{#2}{#3}}}
\newcommand*{\matchRoll}[1]{\elimRoll{#1}}
\newcommand*{\matchSum}[2]{[\exInl{#1}, \exInr{#2}]}
\newcommand*{\matchSumL}[1]{[\exInl{#1}]}
\newcommand*{\matchSumR}[1]{[\exInr{#1}]}
\newcommand*{\matchTrue}[1]{\matchPlug{\exTrue\mapsto}{#1}}
\newcommand*{\matchTrueLow}[1]{\matchPlugLow{\exTrue\mapsto}{#1}}
\newcommand*{\matchTrueNew}{\exTrue}
\newcommand*{\matchUnit}[1]{\exUnit \mapsto {#1}}
\newcommand*{\matchVarLow}[2]{\matchPlugLow{{#1}\mapsto}{#2}}
\newcommand*{\matchVar}[2]{\matchPlug{{#1}\mapsto}{#2}}
\newcommand*{\matchVarNew}[1]{#1}

\newcommand*{\pattToTrie}[2]{\llbracket#1\rrbracket_{#2}}
\newcommand*{\branchesToTrie}[1]{\llbracket#1\rrbracket}
\newcommand*{\matchTrie}[2]{{#1} \triangleleft {#2}}
\newcommand*{\matchTriePartial}[1]{{#1}\:\triangleleft}
\newcommand*{\lookup}[2]{{#1}\,{#2}}
\newcommand*{\lookupR}{\rightsquigarrow}
\newcommand*{\unlookupR}[1]{\mathrel{\sub{\leftsquigarrow}{#1}}}
\newcommand*{\nonEmpty}[1]{\smash{{#1}^{+}}}
\newcommand*{\typeof}[1]{\operatorname{\mathit{type}}(#1)}
\newcommand*{\interpret}[1]{\hat{#1}}
\newcommand*{\elimNarySumUpdate}[3]{#1[#2 \mapsto {#3}]}

% Types.
\newcommand*{\tyBool}[0]{\kw{Bool}}
\newcommand*{\tyData}[1]{#1}
\newcommand*{\tyGround}[1]{#1}
\newcommand*{\tyInt}[0]{\kw{Int}}
\newcommand*{\tyList}[1]{\kw{List}\;{#1}}
\newcommand*{\tyZero}{\kw{0}}
\newcommand*{\tyUnit}{\kw{1}}
\newcommand*{\tySum}[2]{{#1}+{#2}}
\newcommand*{\tyProd}[2]{{#1}\times{#2}}
\newcommand*{\tyFun}[2]{{#1}\rightarrow{#2}}
\newcommand*{\tyRec}[2]{\mu{#1}.{#2}}
\newcommand*{\tyVar}[1]{#1}

\newcommand*{\tyListProj}[1]{\del{\kw{List}}\;{#1}}
\newcommand*{\tySumProjR}[2]{\del{{#1}\:+}\:{#2}}
\newcommand*{\tySumProjL}[2]{{#1}\:\del{+\:{#2}}}
\newcommand*{\tyProdProjR}[1]{\bot\mathbin{\del{\times}}{#1}}
\newcommand*{\tyProdProjL}[1]{{#1}\mathbin{\del{\times}}\bot}
\newcommand*{\tyFunProjR}[2]{\del{{#1}\rightarrow}\:{#2}}
\newcommand*{\tyFunProjL}[2]{{#1}\;\del{\rightarrow{#2}}}
\newcommand*{\tyRecProj}[2]{\del{\mu{#1}.}{#2}}

\newcommand*{\cxtExtendProj}[3]{{#1}\del{,{#2}: {#3}}}
\newcommand*{\envExtendProj}[3]{{#1}\del{[{#2} \mapsto {#3}]}}
\newcommand*{\envErase}[1]{\sub{\bot}{#1}}
\newcommand*{\concatProjL}[2]{{#1}\,\del{\concat\,{#2}}}
\newcommand*{\concatProjR}[2]{\del{{#1}\,\concat}\,{#2}}

\newcommand*{\exAppProjFun}[2]{{#1}\,{\del{#2}}}
\newcommand*{\exConsDel}[2]{\del{\kw{Cons}(}#1, #2\del{)}}
\newcommand*{\exConsProjL}[1]{\del{\kw{Cons}(}#1,\bot\del{)}}
\newcommand*{\exConsProjR}[1]{\del{\kw{Cons}(}\bot,#1\del{)}}
\newcommand*{\exFunProj}[1]{\del{\uplambda}{#1}}
\newcommand*{\exInlProj}[1]{\del{\kw{inl}}\;{#1}}
\newcommand*{\exInrProj}[1]{\del{\kw{inr}}\;{#1}}
\newcommand*{\exLetDel}[3]{\del{\kw{let}\;{#1}=}\;{#2}\;\del{\kw{in}}\;{#3}}
\newcommand*{\exLetProj}[2]{\del{\kw{let}\;{#1}={\bot}\;\kw{in}}\;{#2}}
\newcommand*{\exPairDel}[2]{\del{\langle}#1, #2\del{\rangle}}
\newcommand*{\exPairProjL}[1]{\del{\langle}#1,\bot\del{\rangle}}
\newcommand*{\exPairProjR}[1]{\del{\langle}\bot,#1\del{\rangle}}
\newcommand*{\exRollProj}[1]{\del{\kw{roll}}\;{#1}}

\newcommand*{\elimVarProj}[2]{\del{\elimVarNoRHS{#1}\mapsto}\;{#2}}
\newcommand*{\elimProdProj}[1]{{\del{\langle}#1\del{\rangle}}}
\newcommand*{\elimRollProj}[1]{\del{\kw{roll}}\;{#1}}
\newcommand*{\elimSingletonProj}[2]{\del{#1[}#2\del{]}}
\newcommand*{\elimSumOnlyL}[2]{[\exInl{#1}\del{,\exInr{#2}}]}
\newcommand*{\elimSumOnlyR}[2]{[\del{\exInl{#1},}\,\exInr{#2}]}
\newcommand*{\elimSumProjL}[2]{\del{[\kw{inl}}\;{#1}\del{,\exInr{#2}]}}
\newcommand*{\elimSumProjR}[2]{\del{[\exInl{#1},\kw{inr}}\;{#2}\del{]}}
\newcommand*{\elimSumLProj}[1]{\del{[\kw{inl}}\;{#1}\del{]}}
\newcommand*{\elimSumRProj}[1]{\del{[\kw{inr}}\;{#1}\del{]}}
\newcommand*{\elimUnitProj}[1]{\del{\exUnit\mapsto}\;{#1}}

% Sets
\newcommand*{\Ann}[1]{\Set{Ann}(#1)}
\newcommand*{\Below}[1]{{\downarrow{#1}}}
\newcommand*{\Cxt}{\Set{Cxt}}
\newcommand*{\Env}[1]{\Set{Env}\,#1}
\newcommand*{\Expl}[1]{\Set{Expl}\,#1}
\newcommand*{\ExplVal}[2]{\ExplValPartial{#1}\:#2}
\newcommand*{\ExplValPartial}[1]{\Set{ExplVal}\,#1}
\newcommand*{\Expr}[2]{\ExprPartial{#1}\,#2}
\newcommand*{\ExprPartial}[1]{\Set{Term}\,#1}
\newcommand*{\Match}[4]{\Set{Match}\,#1\,#2\,#3\,#4}
\newcommand*{\Prim}[3]{\Set{Prim}\,#1\,#2\,#3}
\newcommand*{\BinaryOp}[3]{\Set{BinaryOp}\,#1\,#2\,#3}
\newcommand*{\Trie}[3]{\Set{Trie}\,#1\,#2\,#3}
\newcommand*{\UnaryOp}[2]{\Set{UnaryOp}\,#1\,#2}
\newcommand*{\Val}[1]{\Set{Val}\,#1}
\newcommand*{\ValExpl}[2]{\Set{Val}\,#1\:#2}

% Misc.
\newcommand*{\rcons}{\cdot} % can't use \snoc as a macro name inside mathpar
\newcommand*{\cons}{::}
\newcommand*{\unionWith}[1]{\cup_{#1}}
\renewcommand*{\join}{\vee}
\renewcommand*{\meet}{\wedge}
\newcommand*{\joinWith}[1]{\join_{#1}}
\newcommand*{\eqJoin}{\mathbin{!}}

% Variable contexts.
\newcommand*{\cxtBot}{\exBot}
\newcommand*{\cxtEmpty}{\varepsilon}
\newcommand*{\cxtExtend}[3]{{#1},{#2}: {#3}}
\newcommand*{\cxtLookup}[2]{{#1}[{x}]}
\newcommand*{\cxtUpdate}[3]{[{#2}:{#3}]{#1}}
\newcommand*{\cxtConcat}{\plusplus}

% Environments.
\newcommand*{\subst}[3]{{#1}[{#2}/{#3}]} % still needed for recursive types..
\newcommand*{\envEmpty}{\varepsilon}
\newcommand*{\envType}[2]{\vdash {#2}: {#1}}
\newcommand*{\envExtend}[3]{{#1}[{#2} \mapsto {#3}]}
\newcommand*{\envLookup}[3]{{#2}: {#3} \in {#1}}
\newcommand*{\envUpdate}[3]{{#1}\{{#2} \mapsto {#3}\}}
\newcommand*{\envBot}{\bot}
\newcommand*{\recEnvEntry}[3]{(#1,#2,#3)}

% Typing judgements.
\newcommand*{\contType}[3]{{#3} \vdash {#1} : {#2}}
\newcommand*{\elimArrow}{\to}
\newcommand*{\elimTypePartial}[2]{{{#2}\elimArrow{#1}}}
\newcommand*{\elimType}[4]{{#4} \vdash {#1} : \elimTypePartial{#2}{#3}}
\newcommand*{\elimTypeJudge}[3]{{#3} \vdash \elimTypePartial{#1}{#2}}
\newcommand*{\matchArrow}{\rightbarharpoon}
\newcommand*{\matchTypePartial}[2]{{{#2}\matchArrow{#1}}}
\newcommand*{\matchType}[5]{{#1} \vdash {#2} : \matchTypePartial{#3}{#4} \dashv {#5}}
\newcommand*{\explMatchType}[5]{{#1} \vdash {#2} : \Expl{(\matchTypePartial{#3}{#4})} \dashv {#5}}
\newcommand*{\pattTrie}[4]{{#2},{#3} \vdash {#4} \rightsquigarrow {#1}}
\newcommand*{\exprType}[3]{{#2} \vdash {#1} : {#3}}
\newcommand*{\exprTypeJudge}[2]{{#1} \vdash {#2}}
\newcommand*{\pattType}[2]{\vdash {#1} : {#2}}
\newcommand*{\explValType}[3]{{#1} \vdash {#2} : \ExplVal{#3}}
\newcommand*{\explType}[3]{{#1} \vdash {#2} : \Expl{#3}}
\newcommand*{\valType}[2]{\vdash {#1} : {#2}}
\newcommand*{\valExplType}[3]{{#1} \vdash {#2} : {#3}}
\newcommand*{\valExplTypeNew}[2]{\vdash {#1} : {#2}}

% Evaluation.
\newcommand*{\eval}{\mathrel{\Rightarrow}}
% \newcommand*{\fwdSlice}{\nearrow}
% \newcommand*{\bwdSlice}{\searrow}
\newcommand*{\fwdSlice}{\mathrel{\rotatebox[origin=c]{45}{$\eval$}}}
\newcommand*{\bwdSlice}{\mathrel{\rotatebox[origin=c]{-45}{$\eval$}}}
\newcommand*{\uneval}{\Leftarrow}
\newcommand*{\match}{\rightsquigarrow}
\newcommand*{\matchFwd}{\mathrel{\rotatebox[origin=c]{45}{$\rightsquigarrow$}}}
\newcommand*{\matchBwd}{\mathrel{\rotatebox[origin=c]{-45}{$\rightsquigarrow$}}}
\newcommand*{\reduce}[1]{\xlongrightarrow{\textsf{\tiny name}}_{\smash{#1}}}
\newcommand*{\reduceNeed}[1]{\xlongrightarrow{\textsf{\tiny need}}_{\smash{#1}}}
\newcommand*{\close}[2]{\operatorname{\mathsf{close}}(#1,#2)}
\newcommand*{\proj}{\downarrow}
\newcommand*{\nproj}{\not\downarrow}

\newcommand*{\seq}{\mathrel{\smalltriangleright}}

% Traces.
\newcommand*{\trAdd}[4]{\exAdd{#1_{#2}}{#3_{#4}}}
\newcommand*{\trApp}[3]{\exApp{#1}{#2}\seq{#3}}
\newcommand*{\trBot}{\exBot}
\newcommand*{\trCons}[2]{\exCons{#1}{#2}}
\newcommand*{\trConstr}[2]{#1(#2)}
\newcommand*{\trDefs}[2]{\exDefs{#1}{#2}}
\newcommand*{\trEmpty}{\varepsilon}
\newcommand*{\trFalse}{\exFalse}
\newcommand*{\trFun}[1]{\exFun{#1}}
\newcommand*{\trInl}[1]{\exInl{#1}}
\newcommand*{\trInr}[1]{\exInr{#1}}
\newcommand*{\trInt}[1]{\exInt{#1}}
\newcommand*{\trLet}[3]{\kw{let}\;{#1}={#2}\;\kw{in}\;{#3}}
\newcommand*{\trLetDef}[2]{\kw{let}\;{#1}={#2}}
\newcommand*{\trLetrec}[2]{{\kw{letrec}\;{#1}}\;\kw{in}\;{#2}}
\newcommand*{\trLetrecDef}[1]{\exLetrecDef{#1}}
\newcommand*{\trMatch}[2]{\exMatch{#1}{#2}}%\seq_{\lowlight{#3}}{#4}}
\newcommand*{\trNil}{\exNil}
\newcommand*{\trPair}[2]{\exPair{#1}{#2}}
\newcommand*{\trPrimApp}[3]{{#1} #2 {#3}}
\newcommand*{\trPrimDef}[1]{\exPrimDef{#1}}
\newcommand*{\trRec}[2]{\kw{fun}\,{#1}{#2}}
\newcommand*{\trRoll}[1]{\exRoll{#1}}
\newcommand*{\trTrue}{\exTrue}
\newcommand*{\trUnaryApp}[2]{\exApp{#1}{#2}}
\newcommand*{\trUnit}[1]{\sub{\exUnit}{#1}}
\newcommand*{\trVar}[3]{{#1}\seq_{\lowlight{#2}}{#3}}
\newcommand*{\trVarOne}[1]{#1}
\newcommand*{\trVarTwo}[2]{{#1}_{\lowlight{#2}}}

% Self-explaining computation
\newcommand*{\expl}[1]{#1}
\newcommand*{\TrVal}[1]{\mleft\llbracket{#1}\mright\rrbracket}
\newcommand*{\Tr}[1]{{\mathsf{Tr}\TrVal{#1}}}
\newcommand*{\explVal}[2]{{\textcolor{gray}{#1}}\mathrel{::}{#2}}
\newcommand*{\exprTr}[1]{\mathsf{T}(#1)}
