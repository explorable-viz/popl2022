% Data types.
\newcommand*{\defDatatype}[2]{\kw{data}\;{#1}={#2}}
\newcommand*{\defConstr}[2]{#1\symParens{#2}}

% Primitives.
\newcommand*{\primOp}{\oplus}
\newcommand*{\primFwd}[2]{\fwdF{#1}{#2}}
\newcommand*{\primFwdBool}[2]{\upperAdj{\sub{#1}{#2}}}
\newcommand*{\primBwd}[2]{\bwdF{#1}{#2}}
\newcommand*{\primBwdBool}[2]{\lowerAdj{\sub{#1}{#2}}}
\newcommand*{\primGCBool}[2]{\sub{#1}{#2}}
\newcommand*{\primAppF}[1]{\fwdF{primApp}{#1}}
\newcommand*{\primAppGC}[1]{\GC{primApp}{#1}}

% Prelude functions
\newcommand*{\funConcatMap}{\exVar{\kw{concatMap}}}
\newcommand*{\funEnumFromTo}{\exVar{\kw{enumFromTo}}}

\newcommand*{\fieldFst}{\kw{fst}}
\newcommand*{\fieldSnd}{\kw{snd}}

% Expressions.
\newcommand*{\exApp}[2]{{#1}\,{#2}}
\newcommand*{\exAppPrim}[2]{{#1}({#2})}
\newcommand*{\exBinaryApp}[3]{{#1} \mathbin{#2} {#3}}
\newcommand*{\exCons}[2]{{#1}\,\symColon\,{#2}}
\newcommand*{\exConstr}[2]{#1\symParens{#2}}
\newcommand*{\exClosure}[3]{\kw{cl}({#1},{#2},{#3})}
\newcommand*{\exFalse}{\kw{false}}
\newcommand*{\exFun}[2]{#1\,#2}
\newcommand*{\exIfThenElse}[3]{\kw{if}\;{#1}\;\kw{then}\;{#2}\;\kw{else}\;{#3}}
\newcommand*{\exInt}[1]{#1}
\newcommand*{\exList}[2]{\symLBrack\;#1 \ #2}
\newcommand*{\exListComp}[2]{\symLBrack\,{#1}\;\sym{$\vert$}\;{#2}\kw{]}}
\newcommand*{\exListEnd}{\symRBrack}
\newcommand*{\exListEnum}[2]{\symLBrack\,{#1}\;\kw{..}\;{#2}\,\kw{]}}
\newcommand*{\exListNext}[2]{\symComma\;#1 \ #2}
\newcommand*{\exLambda}[1]{\uplambda{#1}}
\newcommand*{\exLet}[3]{\kw{let}\;{#1}\equal{#2}\;\kw{in}\;{#3}}
\newcommand*{\exLetRecEquational}[3]{\kw{let}\;{#1}\;{#2}\;\kw{in}\;{#3}}
\newcommand*{\exLetRec}[3]{\kw{let}\,{#1}{#2}\;\kw{in}\;{#3}}
\newcommand*{\exLetRecMutual}[2]{\kw{let}\;{#1}\;\kw{in}\;{#2}}
\newcommand*{\exMatch}[2]{\kw{match}~{#1}~\kw{as}\;{#2}}
\newcommand*{\exNil}{{\symLBrack}{\symRBrack}}
\newcommand*{\exOp}[1]{\symLParens{#1}\symRParens}
\newcommand*{\exPair}[2]{\symLParens#1\symComma#2\symRParens}
\newcommand*{\exPrim}[1]{#1}
\newcommand*{\exPrimOp}[2]{{#1}({#2})} % value form, analogous to closures
\newcommand*{\exRec}[1]{\symLParens#1\symRParens}
\newcommand*{\exRecProj}[2]{{#1}\symDot{#2}}
\newcommand*{\exRecEmpty}{{\symLParens}{\symRParens}}
\newcommand*{\exStr}[1]{#1}
\newcommand*{\exTrue}{\kw{true}}
\newcommand*{\exVar}[1]{#1}
\newcommand*{\exVec}[3]{\matrixLBrack{#1}\;\sym{$\vert$}\;#2\;\kw{in}\;{#3}\matrixRBrack}
\newcommand*{\exVecVal}[2]{\matrixLBrack{#1}\;\sym{$\vert$}\;{#2}\matrixRBrack}
\newcommand*{\exVecLookup}[2]{{#1}\,\sym{!}\,{#2}}
\newcommand*{\exVecLen}[1]{\kw{len}\;{#1}}

% Annotated expressions
\newcommand*{\annClosure}[4]{\kw{cl}({#1},{#2},{#3},{#4})}
\newcommand*{\annCons}[3]{{#1}\,\symCons_{\hspace{-0.1em}#3}\,{#2}}
\newcommand*{\annFalse}[1]{\kw{false}_{#1}}
\newcommand*{\annList}[3]{\kw{[}_{#3}\;#1 \ #2}
\newcommand*{\annListEnd}[1]{\kw{]}_{#1}}
\newcommand*{\annListComp}[3]{\kw{[}\,{#1}\;\sym{$\vert$}\;{#2}\kw{]}_{#3}}
\newcommand*{\annListNext}[3]{\comma_{#3}\;#1 \ #2}
\newcommand*{\annInt}[2]{#1_{#2}}
\newcommand*{\annMatrix}[5]{\matrixLBrack{#1}\;\sym{$\vert$}\;\exPair{#2}{#3}\;\kw{in}\;{#4}\matrixRBrack_{#5}}
\newcommand*{\annNil}[1]{\kw{[]}_{#1}}
\newcommand*{\annPair}[3]{\exPair{#1}{#2}_{#3}}
\newcommand*{\annRec}[2]{\exRec{#1}_{#2}}
\newcommand*{\annStr}[2]{#1_{#2}}
\newcommand*{\annTrue}[1]{\kw{true}_{#1}}
\newcommand*{\annVec}[4]{\matrixLBrack{#1}\;\sym{$\vert$}\;#2\;\kw{in}\;{#3}\matrixRBrack_{#4}}
\newcommand*{\annVecVal}[3]{\exVecVal{#1}{#2}_{#3}}

% Clause
\newcommand*{\clause}[2]{{#1}\equal{#2}}
\newcommand*{\clauseUncurried}[2]{{#1}\equal{#2}}

% Qualifiers
\newcommand*{\qualGuard}[1]{{#1}}
\newcommand*{\qualDeclaration}[2]{\kw{let}\;{#1}\equal{#2}}
\newcommand*{\qualDone}{\kw{done}}
\newcommand*{\qualGenerator}[2]{{#1}\;\kw{$\leftarrow$}\;{#2}}

% Patterns
\newcommand*{\pattVar}[1]{#1}
\newcommand*{\pattTrue}{\exTrue}
\newcommand*{\pattFalse}{\exFalse}
\newcommand*{\pattCons}[2]{\exCons{#1}{#2}}
\newcommand*{\pattNil}{\exNil}
\newcommand*{\pattList}[2]{\exList{#1}{#2}}
\newcommand*{\pattListNext}[2]{\exListNext{#1}{#2}}
\newcommand*{\pattListEnd}{\exListEnd}
\newcommand*{\pattPair}[2]{\exPair{#1}{#2}}
\newcommand*{\pattRec}[1]{\exRec{#1}}
\newcommand*{\pattRecEmpty}{\exRecEmpty}

% Eliminators.
\newcommand*{\elimmapsto}{{:}\;}
\newcommand*{\branch}[2]{{#1}\elimmapsto{#2}}

\newcommand*{\elimConstr}[1]{\symBrace{#1}}
\newcommand*{\elimRec}[2]{\{\exRec{#1}\elimmapsto{#2}\}}
\newcommand*{\elimRecEmpty}[1]{\{\exRecEmpty\elimmapsto{#1}\}}
\newcommand*{\elimVar}[2]{{#1}\elimmapsto{#2}} % no squigglies as not a 'set' of branches

% Semantics
\newcommand*{\toJSCore}[1]{\llbracket#1\rrbracket}
\newcommand*{\toJSCoreConstr}[2]{\toJSCore{#2}_{#1}}
\newcommand*{\toJSCoreFwd}[2]{\toJSCore{#2}^{\rightsquigarrow}_{#1}}

% Sets
\newcommand*{\Elim}[2]{\Set{Elim}\,{#1}\,{#2}}
\newcommand*{\Expr}[1]{\Set{Expr}\,{#1}}
